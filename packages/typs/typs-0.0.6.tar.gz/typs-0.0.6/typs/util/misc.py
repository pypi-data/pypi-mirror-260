# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/00_util/09_misc.ipynb.

# %% auto 0
__all__ = ['dunann', 'duncal', 'dundoc', 'dunini', 'dunnew', 'dunsig', 'dunname', 'find_spec_or_none', 'find_last_spec',
           'prep_kwargs', 'asset_attrs', 'asset_sub_pkg', 'asset_last', 'asset_name', 'parse_asset', 'insys',
           'find_asset_module', 'load_asset', 'try_loaded_attr', 'try_ducked_attr', 'unduck',
           'prepare_types_for_instancecheck', 'tryattr', 'makegetter', 'trysig', 'getsig', 'setsig', 'newtype',
           'unionify', 'getorigintypes', 'opttypes', 'guardtype', 'filtkwds', 'getname', 'argname', 'argsname',
           'classname', 'qualname']

# %% ../../nbs/00_util/09_misc.ipynb 6
import io, sys, inspect
from functools import wraps

from contextlib import redirect_stderr, redirect_stdout

from importlib.abc import Loader
from importlib.util import (module_from_spec, find_spec)
from importlib.machinery import ModuleSpec

from inspect import Signature, signature
from functools import wraps

# %% ../../nbs/00_util/09_misc.ipynb 8
from types import ModuleType, MethodWrapperType
from typing import (Any, Dict, Union, Iterable, TypeGuard, Callable, Optional, get_args, )
import typing

# %% ../../nbs/00_util/09_misc.ipynb 10
#| export


# %% ../../nbs/00_util/09_misc.ipynb 12
#| export


# %% ../../nbs/00_util/09_misc.ipynb 14
from .cons import (
    DOT, NIL, LOAD, LOADER, DUCK_SPEC_ATTRS, 
    __DOC__, __NEW__, __CALL__, __INIT__, __NAME__, __MODULE__, __SIGNATURE__, __ANNOTATIONS__,)
from .type import T, P, Types, Guard, Namespace
from .prot import NotSpecial, DuckSpecProtocol, DuckModuleProtocol
from .grds import isnotspecial, isnotiterstr, isduckspec, isduckmodule, hasduck, hasload, isclstype
from .errs import (DuckException, DuckNameError, DuckImportError, DuckAttributeError, DuckModuleNotFoundError)
from .attr import attribute

# %% ../../nbs/00_util/09_misc.ipynb 16
@wraps(find_spec)
def find_spec_or_none(name: str, package: str | None = None) -> ModuleSpec | None:
    # NOTE: needed as find_spec will fail if stub is an attribute e.g. 
    # `pandas.core.arrays.categorical.CategoricalAccessor`
    try: return find_spec(name, package)
    except ModuleNotFoundError: return None

def find_last_spec(fullpath: str) -> tuple[ModuleSpec | None, str | None]:
    stubs = fullpath.split(DOT)
    while len(stubs) > 0:
        stub = DOT.join(stubs)
        spec = find_spec_or_none(stub)
        if spec: break
        stubs.pop()
    return spec, stub

# %% ../../nbs/00_util/09_misc.ipynb 18
def prep_kwargs(obj: object, *args: P.args, __attrs: tuple[str, ...] = DUCK_SPEC_ATTRS, **kwargs: P.kwargs) -> dict:
    objkws, argkws = dict(),  dict(zip(__attrs, args))
    for i, attr in enumerate(__attrs):
        objkws.setdefault(attr, getattr(obj, attr, None))
        argkws.setdefault(attr, objkws.get(attr))
        kwargs.setdefault(attr, argkws.get(attr))
    return kwargs

# %% ../../nbs/00_util/09_misc.ipynb 20
def asset_attrs(asset) -> tuple[str, ...]:
    *_, rest = asset.removesuffix(DOT).partition(DOT)
    return rest.split(DOT)

def asset_sub_pkg(asset) -> tuple[str, str]:
    name, _, attr = asset.removesuffix(DOT).rpartition(DOT)
    return name, attr

def asset_last(asset: str) -> str:
    *_, name = str(asset).removesuffix(DOT).rpartition(DOT)
    return name

def asset_name(asset, is_module: bool = False) -> str:
    if is_module or DOT not in asset: return asset
    name, _ = asset_sub_pkg(asset)
    return name

def parse_asset(asset: str, is_module: bool = False) -> tuple[str, str | None]:
    if is_module or DOT not in asset: return asset, None
    name, attr = asset_sub_pkg(asset)
    return name, attr

# %% ../../nbs/00_util/09_misc.ipynb 25
def insys(asset: str, is_module: bool = False) -> bool:
    return asset_name(asset, is_module) in sys.modules

def find_asset_module(asset: str, is_module: bool = False) -> ModuleType:
    name, attr = parse_asset(asset, is_module)
    if insys(asset, is_module): return sys.modules[name]
    
    spec: ModuleSpec | None = find_spec(name)
    module: ModuleType = module_from_spec(spec)
    loader: Loader = getattr(spec, LOADER, None)
    
    try: loader.exec_module(module)
    except NameError as e: ...
    return module

def load_asset(asset: str, is_module: bool = False):
    name, attr = parse_asset(asset, is_module)
    module = find_asset_module(asset, is_module)
    if is_module or attr is None: return module
    return getattr(module, attr)

def try_loaded_attr(asset: str, is_module: bool = False, hush: bool = False):
    if not hush: return load_asset(asset, is_module)
    with redirect_stderr(io.StringIO()), redirect_stdout(io.StringIO()):
        return load_asset(asset, is_module)

# %% ../../nbs/00_util/09_misc.ipynb 27
def try_ducked_attr(asset: str, ducked: Optional[DuckSpecProtocol] = None):
    if ducked is None: raise DuckImportError(asset)
    try:
        item = ducked
        for attr in asset_attrs(asset):
            item = getattr(item, attr)
        return item
    except NameError as e: raise DuckNameError(*e.args)
    except ModuleNotFoundError as e: raise DuckModuleNotFoundError(*e.args, e.name, e.path)
    except ImportError as e: raise DuckImportError(*e.args, e.name, e.path)
    except AttributeError as e: raise DuckAttributeError(*e.args, e.name, e.obj)
    except Exception as e: raise DuckException(*e.args)
    return item

# %% ../../nbs/00_util/09_misc.ipynb 29
def unduck(item: Any):
    try:
        if isduckspec(item): return item.duck
        elif callable(getattr(item, LOAD, None)):
            return item.load()
    except Exception: ...
    return item

def _fromducks(var: Iterable):
    iterstr = isnotiterstr(var)
    if not iterstr: return var
    for i, e in enumerate(var): var[i] = unduck(e)
    return var

def _fromcall(var: Iterable):
    if not callable(var): return var
    try: return var()
    except: ...
    return var

# %% ../../nbs/00_util/09_misc.ipynb 30
def prepare_types_for_instancecheck(types: tuple[type, ...]) -> tuple[type, ...]:
    results = []
    for t in types:
        if hasduck(t): 
            try:
                results.append(t.duck)
                continue
            except Exception: ...
        if hasload(t): 
            try:
                results.append(t.load())
                continue
            except Exception: ...
            
        if isclstype(t): 
            results.append(t)
        else: 
            results.append(type(t))
    
    return tuple(results)

# %% ../../nbs/00_util/09_misc.ipynb 32
def tryattr(
    asset: str, 
    is_module: bool = False, 
    ducked: Optional[DuckModuleProtocol] = None,
    default: Any = None,
    bases: tuple = (),
    attrs: dict = {},
    hush: bool = True,
    delayed: dict[str, bool] = dict(),
    **kwargs
) -> type:
    item, ierr, derr = None, False, False
    try: item = try_loaded_attr(asset, is_module, hush=hush)         
    except (NameError, ImportError, AttributeError): ierr = True    
    
    if isinstance(item, ModuleType) and is_module: return item
    elif not ierr: return item
    
    try: item = try_ducked_attr(asset, ducked)
    except (DuckException, DuckNameError, DuckImportError, DuckAttributeError, DuckModuleNotFoundError): derr = True
            
    attr = asset_last(asset)
    
    isducked = isduckmodule(item)


    itemname = getattr(item, __NAME__, None)
    goodname, notfound = attr == itemname, attr != itemname
    maketype: bool = (isducked and notfound) or (ierr or derr) or default in (None, type)
    
    found = not isducked and goodname
    if found: return item
    
    
    for k, v in delayed.items():
        if not v and k in locals(): continue
        var = locals().get(k)
        var = _fromducks(var)
        var = _fromcall(var)
        try:
            match k:
                case 'attrs': attrs = var()
                case 'bases': bases = var()
                case 'default': default = var()
                case _: ...
        except: ...
    
    try:
        if maketype: 
            moddict = dict(__module__=globals().get(__MODULE__, 'typs'))
            attrs.update(moddict)
            item = type(attr, bases, attrs)
            
        else: item = default
    
    except Exception: 
        item = default
    
    item = unduck(item)
    return item

# %% ../../nbs/00_util/09_misc.ipynb 36
def makegetter(attr: str, retself: bool = False) -> Callable:
    @wraps(getattr)
    def get(obj: object, default = None) -> object:
        return getattr(obj, attr, obj if retself else default)
    return get

dunann, duncal, dundoc, dunini, dunnew, dunsig = map(makegetter, (
    __ANNOTATIONS__, __CALL__, __DOC__, __INIT__, __NEW__, __SIGNATURE__))

dunname = makegetter(__NAME__, True)

# %% ../../nbs/00_util/09_misc.ipynb 37
dunname = attribute(__NAME__, retself=True)
'''Getter for the dunder `__name__` attribute of the given object.''';

# %% ../../nbs/00_util/09_misc.ipynb 39
def trysig(o: object) -> Optional[Signature]:
    '''Attempt to retrieve the signature of an object.'''
    try: 
        return signature(o)
    except: 
        ...

def getsig(o: object) -> Signature:
    '''Retrieve the signature of an object, attempting multiple strategies if necessary.'''
    # NOTE: desparate try to get a signature from anywhere
    duns = (dunsig, duncal, dunini, dunnew, dunann)
    vals = {dunname(fn): fn(o) for fn in (lambda x: x, *duns)}
    for _, val in vals.items():
        if (sig := trysig(val)): return sig
        
    # NOTE: if all else fails, try to get a signature from the annotations
    for _, val in vals.items():
        if (sig := dunsig(val)): 
            return sig
    return Signature([])

def setsig(wrapper: MethodWrapperType, attr: Callable) -> MethodWrapperType:
    '''Set the signature of a method wrapper based on an attribute's signature.'''
    sig = getsig(attr)
    setattr(wrapper, __SIGNATURE__, sig)
    
    if hasattr(wrapper, __CALL__) and hasattr(duncal(wrapper), __SIGNATURE__): 
        wrapper.__call__.__signature__ = sig
    if hasattr(wrapper, __INIT__) and hasattr(dunini(wrapper), __SIGNATURE__): 
        wrapper.__init__.__signature__ = sig
    
    setattr(wrapper, __ANNOTATIONS__, dunann(attr, dunann(wrapper)))
    setattr(wrapper, __DOC__, dundoc(attr, dundoc(wrapper)))
    return wrapper

# %% ../../nbs/00_util/09_misc.ipynb 41
def newtype(
    name: str = NIL,
    bases: Union[Types, type] = tuple(), 
    space: Namespace = dict(),
    *, 
    cls: Optional[type] = None, 
    **kwargs
) -> type:
    '''
    Create a new type using type.__new__.

    Parameters
    ----------
    name : str
        The name of the type.

    bases : Union[Types, type]
        A tuple containing base classes of the new type, or a single base class.
        
    space : Union[dict, namespace]
        A dictionary containing attributes and methods of the new type.

    cls : Optional[type]
        A metaclass for the new type, defaults to None.

    **kwargs
        Additional keyword arguments to be included in the type's dictionary.

    Returns
    -------
    type
        The newly created type.

    Notes
    -----
    Calls `newtype` is equvialent to either

    type(name, bases, dict) : 
        if no class `cls` is provided, or

    type.__new__(cls, name, bases, dict) : 
        if a class `cls` is provided.
    '''
    space.update(kwargs)
    if not isinstance(bases, tuple):
        bases = tuple((bases, ))
        
    if cls is None:
        return type(name, tuple(bases), space)
    
    return type.__new__(cls, name, tuple(bases), space)

# %% ../../nbs/00_util/09_misc.ipynb 43
def unionify(*t: Types) -> Union[None, type, Types]:
    '''Create a union type from given types, handling `None` and single type cases.'''
    return None if (n := len(t)) == 0 else t[0] if n == 1 else Union[t[0], *t[1:]]

def getorigintypes() -> list[NotSpecial]:
    '''Retrieve a list of non-special types from the `typing` module.'''
    return [a for e in dir(typing) if isnotspecial(a := getattr(typing, e))]

def opttypes(types: Types, dropnone: bool = True) -> Types:
    '''Optionally wrap types in a `typing.Optional` type, excluding `None` if specified.

    Parameters
    ----------
    types : Types
        A tuple of types to be optionally wrapped in `typing.Optional`.
        
    dropnone : bool, default True
        Whether to exclude `None` type from the resulting tuple.

    Returns
    -------
    Types
        A tuple of types, optionally wrapped in `typing.Optional`.
    '''
    return types if not dropnone else tuple(Optional[t] for t in types if t is not None)

def guardtype(*types: Types) -> Guard:
    '''Create a TypeGuard for a union of the given types.

    Parameters
    ----------
    *types : Types
        A variadic number of type variables to be included in the class's qualified name.
        
    Returns
    -------
    Guard
        A TypeGuard for the union of the given types.
    '''
    return TypeGuard[unionify(*opttypes(types))]

# %% ../../nbs/00_util/09_misc.ipynb 45
def filtkwds(fn: Callable, **kwargs) -> Dict[str, Any]:
    '''Filter keyword arguments to only include those that are valid for a given function's signature.

    Parameters
    ----------
    fn : Callable
        The function whose signature is to be considered for filtering.
        
    **kwargs : dict
        Keyword arguments to be filtered based on the function's signature.

    Returns
    -------
    Dict[str, Any]
        A dictionary of keyword arguments that are valid for the function's signature.
    '''
    sig = signature(fn).parameters
    return {k: v for k, v in kwargs.items() if k in sig}

def getname(o: object) -> str:
    '''Get the name of an object or its string representation if the name is not directly accessible.

    Parameters
    ----------
    o : object
        The object whose name is to be retrieved.

    Returns
    -------
    str
        The name of the object or its string representation.
    '''
    return str(dunname(o))

def argname(a: T) -> str:
    '''Retrieve the name of the first argument type for a given type variable.

    Parameters
    ----------
    a : T
        A type variable whose first argument type's name is to be retrieved.

    Returns
    -------
    str
        The name of the first argument type of the type variable.
    '''
    return getname((get_args(a) or (a, ))[0])

def argsname(*args: Types, sep: str = ', ') -> str:
    '''Concatenate the names of the argument types for a list of type variables.

    Parameters
    ----------
    *args : Types
        A variadic number of type variables.
        
    sep : str, default: ', '
        The separator to use when concatenating the names of the argument types.

    Returns
    -------
    str
        A comma-separated string of the names of the argument types.
    '''
    return sep.join(list(map(argname, args)))

def classname(cls: type, alt: Optional[str] = None) -> str:
    '''Retrieve the name of a class, or an alternate name if provided.

    Parameters
    ----------
    cls : type
        The class whose name is to be retrieved.
        
    alt : Optional[str], optional
        An alternate name to return instead of the class's name.

    Returns
    -------
    str
        The name of the class or the alternate name if provided.
    '''
    if inspect.isclass(alt): return getname(alt)
    if isinstance(alt, str): return alt
    return getname(cls)

def qualname(
    cls: type, 
    *types: Types, 
    prefix: str = NIL, 
    suffix: str = NIL, 
    dropnone: bool = True, 
    alt: Optional[str] = None,
) -> str:
    '''Generate a qualified name for a class with specific type parameters and optional prefix/suffix.

    Parameters
    ----------
    cls : type
        The class for which the qualified name is to be generated.
        
    *types : Types
        A variadic number of type variables to be included in the class's qualified name.
        
    prefix : str, optional
        A prefix to be added to the qualified name.
        
    suffix : str, optional
        A suffix to be added to the qualified name.
        
    dropnone : bool, default True
        Whether to exclude `None` type from the type variables.
        
    alt : Optional[str], optional
        An alternative name to use instead of the class's name.

    Returns
    -------
    str
        The generated qualified name of the class.
    '''
    types = opttypes(types, dropnone)
    cname = classname(cls, alt)
    qname = f'{prefix}{{{argsname(*types)}}}{suffix}'    
    qname = f'{cname}({qname})'
    return qname
