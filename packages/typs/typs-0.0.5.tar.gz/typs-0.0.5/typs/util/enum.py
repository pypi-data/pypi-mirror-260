# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/00_util/04_enum.ipynb.

# %% auto 0
__all__ = ['PROTOCOL_METHOD_ORDER', 'Species', 'LoaderState', 'ProtocolMethod', 'ProtocolMethodOrder']

# %% ../../nbs/00_util/04_enum.ipynb 6
import io
from enum import Enum, StrEnum, auto
from contextlib import redirect_stdout, redirect_stderr
from importlib.machinery import ModuleSpec

# %% ../../nbs/00_util/04_enum.ipynb 8
from types import ModuleType
from typing import (Any, Union, Iterable, Optional)

# %% ../../nbs/00_util/04_enum.ipynb 10
#| export

# %% ../../nbs/00_util/04_enum.ipynb 12
#| export

# %% ../../nbs/00_util/04_enum.ipynb 14
from .cons import NIL, VALUE, LOADER_STATE, _DEFAULT_, __SPEC__

# %% ../../nbs/00_util/04_enum.ipynb 17
class Species(StrEnum):
    '''Cheeky enum to represent the "species" (i.e. flavor) of a duck-typed protocol.'''
    REG = auto()
    NOT = auto()
    OPT = auto()
    
    @classmethod
    def contains(cls, item: Any, items: Iterable, kind: 'Species' = 'reg') -> bool:
        kind = cls(kind)
        match kind:
            case cls.REG: return item in items
            case cls.NOT: return item not in items
            case cls.OPT: return True
            case _: return False
            

# %% ../../nbs/00_util/04_enum.ipynb 23
class LoaderState(StrEnum):
    '''The state of the module loader.

    Attributes
    ----------
    NONE : auto
        Indicates no state.
    EXECED : auto
        Indicates the module has been executed.
    DUCKED : auto
        Indicates the module has been duck-typed.
    UNKNOWN : auto
        Indicates an unknown state.

    Methods
    -------
    _missing_(value: object) -> 'LoaderState'
        Provides a default for missing values.
    spec(module: ModuleType) -> Optional[ModuleSpec]
        Retrieves the module spec.
    get(module: ModuleType) -> 'LoaderState'
        Retrieves the loader state for a module.
    set(module: ModuleType, state: Optional[Union['LoaderState', str]] = None) -> ModuleType
        Sets the loader state for a module.
    exec(module: ModuleType) -> ModuleType
        Executes the module and sets its state to DUCKED.
    '''
    NONE = auto()
    EXECED = auto()
    DUCKED = auto()
    UNKNOWN = auto()
    
    @classmethod
    def _missing_(cls, value: object) -> 'LoaderState':
        if value is None: return cls.NONE
        return cls.UNKNOWN 

    @classmethod
    def spec(cls, module: ModuleType) -> Optional[ModuleSpec]:
        try: return object.__getattribute__(module, __SPEC__)
        except: return None
        
    @classmethod
    def get(cls, module: ModuleType) -> 'LoaderState':
        try: return cls(cls.spec(module).loader_state)
        except: return cls.UNKNOWN

    @classmethod
    def set(cls, module: ModuleType, state: Optional[Union['LoaderState', str]] = None) -> ModuleType:
        try: setattr(cls.spec(module), LOADER_STATE, str(cls(state)))
        except: ...
        return module
        
    @classmethod
    def exec(cls, module: ModuleType) -> ModuleType:
        spec = cls.spec(module)
        with redirect_stdout(io.StringIO()), redirect_stderr(io.StringIO()):
            spec.loader.exec_module(module)
            # try: spec.loader.exec_module(module)
            # except NameError: ...
        return cls.set(module, cls.DUCKED)

# %% ../../nbs/00_util/04_enum.ipynb 25
class ProtocolMethod(StrEnum):
    '''Methods for the custom protocol type.
    
    Attributes
    ----------
    generator : str
        Try to generate a class from the protocol's `types`.
        
    decorator : str
        Use the protocol as a decorator for a class.
        
    inschecks : str
        Call the protocol's `__instancecheck__` method over varadic arguments.

    typeguard : str
        Use the progocol's `types` to create a typeguard function.
    '''
    # Option 1: try to construct a class from the protocol's `types`
    GENERATOR = auto()
    '''Try to generate a class from the protocol's `types`.''';
    
    # Option 2: decorate a class
    DECORATOR = auto()
    
    # Option 3: call `__instancecheck__` / `check(...)` over varadic arguments
    INSTCHECK = auto()
    '''Call the protocol's `__instancecheck__` method over varadic arguments.''';
    
    # Option 4: create a typeguard function from the protocol's `types`
    TYPEGUARD = auto()
    '''Use the progocol's `types` to create a typeguard function.''';
    
    @classmethod
    def _missing_(cls: 'ProtocolMethod', val: str, default = None):
        # Case-Insensitive Search
        for mem in cls:
            if mem.ieq(val): return mem
            
        # Check for default sunder method
        if hasattr(cls, _DEFAULT_): 
            edef = cls._default_()
            try: return cls(edef)
            except: ...
            try: return cls(default)
            except: return default
        
        # Check for startswith
        for mem in cls:
            if mem.startswith(val): return mem
            
        return default
    
    def casefold(self) -> str:
        return str(getattr(self, VALUE, NIL)).casefold()
    
    def ieq(self, val: str) -> bool:
        if self.casefold() == str(val).casefold(): return True
        try: 
            if self == str(val).casefold(): return True
        except: return False
    
    def startswith(self, val: str) -> bool:
        if self.casefold().startswith(str(val).casefold()): return True
        try:
            if self.value.startswith(val) == str(val): True
        except: return False
        
    
    @classmethod
    def idgt(cls) -> tuple['ProtocolMethod', ...]:
        return (
            ProtocolMethod.INSTCHECK, 
            ProtocolMethod.DECORATOR, 
            ProtocolMethod.GENERATOR, 
            ProtocolMethod.TYPEGUARD
        )
    
    @classmethod
    def gidt(cls) -> tuple['ProtocolMethod', ...]:
        return (
            ProtocolMethod.GENERATOR, 
            ProtocolMethod.DECORATOR, 
            ProtocolMethod.INSTCHECK, 
            ProtocolMethod.TYPEGUARD
        )

# %% ../../nbs/00_util/04_enum.ipynb 26
class ProtocolMethodOrder(Enum):
    idgt = (
            ProtocolMethod.INSTCHECK, 
            ProtocolMethod.DECORATOR, 
            ProtocolMethod.GENERATOR, 
            ProtocolMethod.TYPEGUARD
        )
    
    gidt = (
            ProtocolMethod.GENERATOR, 
            ProtocolMethod.DECORATOR, 
            ProtocolMethod.INSTCHECK, 
            ProtocolMethod.TYPEGUARD
        )
    
    
PROTOCOL_METHOD_ORDER = (
    ProtocolMethod.INSTCHECK, 
    ProtocolMethod.DECORATOR, 
    ProtocolMethod.GENERATOR, 
    ProtocolMethod.TYPEGUARD
)
'''Options for the overloaded `ProtoType.__call__` method.''';
