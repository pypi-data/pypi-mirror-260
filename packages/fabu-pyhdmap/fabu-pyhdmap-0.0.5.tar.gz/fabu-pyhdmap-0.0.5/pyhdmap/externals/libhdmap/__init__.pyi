# -*- coding: utf-8 -*-

from tokenize import Double
from typing import Any, List, Tuple


def SetRuntimeFlags(flag_file_content: str, program_name: str,
                    errors_are_fatal: bool) -> bool: ...


def GetRuntimeFlags() -> str: ...


def InitLogging(program_name: str) -> None : ...


class Vec2d:
    def __init__(self, x: float, y: float) -> None: ...

    def CreateUnitVec2d(self, angle: float) -> None: ...

    def x(self) -> float: ...

    def y(self) -> float: ...

    def set_x(self, value: float) -> None: ...

    def set_y(self, value: float) -> None: ...

    def Length(self) -> float: ...

    def LengthSquare(self) -> float: ...

    def Angle(self) -> float: ...

    def Normalize(self) -> None: ...

    def DistanceTo(self, other: Vec2d) -> float: ...

    def DistanceSquareTo(self, other: Vec2d) -> float: ...

    def CrossProd(self, other: Vec2d) -> float: ...

    def InnerProd(self, other: Vec2d) -> float: ...

    def rotate(self, angle: float) -> Vec2d: ...

    def DebugString(self) -> str: ...


class SDPoint(Vec2d):
    def __init__(self, s: float, d: float) -> None: ...

    def s(self) -> float: ...

    def d(self) -> float: ...

    def set_s(self, value: float) -> None: ...

    def set_d(self, value: float) -> None: ...

    def DebugString(self) -> str: ...


class LineSegment2d:
    def __init__(self, start: Vec2d, end: Vec2d) -> None: ...

    def start(self) -> Vec2d: ...

    def end(self) -> Vec2d: ...

    def unit_direction(self) -> Vec2d: ...

    def center(self) -> Vec2d: ...

    def heading(self) -> float: ...

    def cos_heading(self) -> float: ...

    def sin_heading(self) -> float: ...

    def length(self) -> float: ...

    def length_sqr(self) -> float: ...

    def DistanceTo(self, point: Vec2d, nearest_pt: Vec2d = None) -> float: ...

    def DistanceSquareTo(self, point: Vec2d,
                         nearest_pt: Vec2d = None) -> float: ...

    def IsPointIn(self, point: Vec2d) -> bool: ...

    def HasIntersect(self, other_segment: LineSegment2d) -> bool: ...

    def GetIntersect(self, other_segment: LineSegment2d,
                     point: Vec2d) -> bool: ...

    def ProjectOntoUnit(self, point: Vec2d) -> float: ...

    def ProductOntoUnit(self, point: Vec2d) -> float: ...

    def GetPerpendicularFoot(
        self, point: Vec2d, foot_point: Vec2d) -> float: ...

    def DebugString(self) -> str: ...


class AABox2d:

    def __init__(self, center: Vec2d, length: float, width: float) -> None: ...

    def __init__(self, one_corner: Vec2d, opposite_corner: Vec2d) -> None: ...

    def __init__(self, points: List[Vec2d]) -> None: ...

    def center(self) -> Vec2d: ...

    def center_x(self) -> float: ...

    def center_y(self) -> float: ...

    def length(self) -> float: ...

    def width(self) -> float: ...

    def half_length(self) -> float: ...

    def half_width(self) -> float: ...

    def area(self) -> float: ...

    def min_x(self) -> float: ...

    def max_x(self) -> float: ...

    def min_y(self) -> float: ...

    def max_y(self) -> float: ...

    def GetAllCorners(self) -> List[Vec2d]: ...

    def IsPointIn(self, point: Vec2d) -> bool: ...

    def IsPointOnBoundary(self, point: Vec2d) -> bool: ...

    def DistanceTo(self, object: Any[Vec2d, AABox2d]) -> float: ...

    def HasOverlap(self, box: AABox2d) -> bool: ...

    def GetOverlap(self, box: AABox2d, is_union: bool) -> float: ...

    def Shift(self, shift_vec: Vec2d) -> None: ...

    def MergeFromAABox2d(self, other_box: AABox2d) -> None: ...

    def MergeFromVec2d(self, other_point: Vec2d) -> None: ...

    def DebugString(self) -> str: ...


class Box2d:
    def __init__(self, center: Vec2d, heading: float,
                 length: float, width: float) -> None: ...

    def __init__(self, axis: LineSegment2d, width: Vec2d) -> None: ...

    def __init__(self, aabox: AABox2d) -> None: ...

    @staticmethod
    def CreateAABox(one_corner: Vec2d, opposite_corner: Vec2d) -> Box2d: ...

    @staticmethod
    def CreateAABox(points: List[Vec2d]) -> Box2d: ...

    @staticmethod
    def CreateBox2d(sepoints: List[Vec2d]) -> Box2d: ...

    def CreateMergedBox2d(self, box: Box2d) -> Box2d: ...

    def center(self) -> Vec2d: ...

    def corners(self) -> List[Vec2d]: ...

    def center_x(self) -> float: ...

    def center_y(self) -> float: ...

    def length(self) -> float: ...

    def width(self) -> float: ...

    def half_length(self) -> float: ...

    def half_width(self) -> float: ...

    def heading(self) -> float: ...

    def cos_heading(self) -> float: ...

    def sin_heading(self) -> float: ...

    def area(self) -> float: ...

    def diagonal(self) -> float: ...

    def GetAllCorners(self) -> List[Vec2d]: ...

    def IsPointIn(self, point: Vec2d) -> bool: ...

    def IsPointOnBoundary(self, point: Vec2d) -> bool: ...

    def DistanceTo(self, object: Any[Vec2d, LineSegment2d, Box2d]): ...

    def DistanceToVec2d(self, point: Vec2d) -> float: ...

    def DistanceToLineSegment2d(
        self, line_segment: LineSegment2d) -> float: ...

    def DistanceToBox2d(self, box: Box2d) -> float: ...

    def HasOverlap(self, object: Any[LineSegment2d, Box2d]) -> bool: ...

    def AreaOfUnion(self, box: Box2d) -> float: ...

    def AreaOfIntersection(self, box: Box2d) -> float: ...

    def IoU(self, box: Box2d) -> float: ...

    def GetAABox(self) -> AABox2d: ...

    def RotateFromCenter(self, rotate_angle: float) -> None: ...

    def Shift(self, shift_vec: Vec2d) -> None: ...

    def LongitudinalExtend(self, extension_length: float) -> None: ...

    def LateralExtend(self, extension_length: float) -> None: ...

    def DebugString(self) -> str: ...

    def InitCorners(self) -> None: ...

    def max_x(self) -> float: ...

    def min_x(self) -> float: ...

    def max_y(self) -> float: ...

    def min_y(self) -> float: ...

    def IsValid(self) -> bool: ...


class Curve:

    def x(s: float) -> float: ...

    def y(s: float) -> float: ...

    def FitCurve(xs: List[float], yx: List[float]) -> None: ...


class Polygon2d:

    def __init__(self, box: Box2d) -> None: ...

    def __init__(self, points: List[Vec2d]) -> None: ...

    def __init__(self, polygon: Polygon2d) -> None: ...

    def points(self) -> List[Vec2d]: ...

    def line_segments(self) -> List[LineSegment2d]: ...

    def num_points(self) -> int: ...

    def is_convex(self) -> bool: ...

    def area(self) -> float: ...

    def DistanceToBoundary(self, point: Vec2d) -> float: ...

    def DistanceTo(self, point: Vec2d) -> float: ...

    def DistanceTo(self, line_segment: LineSegment2d) -> float: ...

    def DistanceTo(self, box: Box2d) -> float: ...

    def DistanceTo(self, polygon: Polygon2d) -> float: ...

    def DistanceSquareTo(self, point: Vec2d) -> float: ...

    def IsPointIn(self, point: Vec2d) -> bool: ...

    def IsPointOnBoundary(self, point: Vec2d) -> bool: ...

    def Contains(self, line_segment: LineSegment2d) -> bool: ...

    def Contains(self, polygon: Polygon2d) -> bool: ...

    @staticmethod
    def ComputeConvexHull(points: List[Vec2d], polygon: Polygon2d) -> None: ...

    def HasOverlap(self, line_segment: LineSegment2d) -> bool: ...

    def GetOverlap(self, line_segment: LineSegment2d,
                   first: Vec2d, last: Vec2d) -> bool: ...

    def GetAllOverlaps(
        self, line_segment: LineSegment2d) -> List[LineSegment2d]: ...

    def HasOverlap(self, polygon: Polygon2d) -> bool: ...

    def ComputeOverlap(self, other_polygon: Polygon2d,
                       overlap_polygon: Polygon2d) -> bool: ...

    def AABoundingBox(self) -> AABox2d: ...

    def BoundingBoxWithHeading(self, heading: float) -> Box2d: ...

    def MinAreaBoundingBox(self) -> Box2d: ...

    def ExtremePoints(self, heading: float, first: Vec2d,
                      last: Vec2d) -> None: ...

    def ExpandByDistance(self, distance) -> Polygon2d: ...

    def DebugString(self) -> str: ...

    def min_x(self) -> float: ...

    def max_x(self) -> float: ...

    def min_y(self) -> float: ...

    def max_y(self) -> float: ...


class HDMapManager:
    @ staticmethod
    def LoadMap(map_file_path: str, business_scene: str) -> bool: ...

    @ staticmethod
    def LoadMapDir(map_dir: str, business_scene: str) -> bool: ...

    @ staticmethod
    def Reload(vessel_status_bytes: str) -> bool: ...

    @staticmethod
    def ReloadForHdmapService(
        vessels: List[List[float]], vessel_uuids: List[str]) -> bool: ...
    
    @staticmethod
    def PreprocessForHdmapService(
        map_file_path: str, business_scene: str, save_dir: str) -> bool: ...

    @staticmethod
    def TestVesselFromVecList(
        vessels: List[List[float]]) -> List[List[float]]: ...

    @ staticmethod
    def GetHDMap() -> HDMap: ...

    @ staticmethod
    def GetReloadVesselStatus() -> List[HdmapVessel]: ...

    @ staticmethod
    def GetVesselStatus() -> str: ...


class HDMap:
    def LoadMap(self, map_file_path: str, business_scene: str) -> bool: ...
    
    def LoadMapWithMode(self, map_file_path: str, business_scene: str, mode: int) -> bool: ...

    def LoadGround(self, ground_file_path: str) -> bool: ...

    def LoadMapDir(self, map_dir: str, business_scene: str) -> bool: ...

    def Reload(self, vessel_status_bytes: str) -> bool: ...

    def GetDockProjection(self, point: Vec2d) -> Tuple[float, float]: ...
    
    def ValidateForHdmapService(
        vessels: List[List[float]], vessel_flag: List[str]) -> Tuple[bool, List[List[List[str]]], List[HdmapVessel]]: ...

    def GetDockDynamicBlockByIndex(
        self, vessel_uuid: str, index: int) -> List[BlockLane]: ...
    
    def JudgeGirderDirection(self, solved_vessels: List[CloudServiceVessel], cur_vessel: CloudServiceVessel) -> Tuple[int, CloudServiceVessel, GirderAffect, GirderAffect]: ...

    def GetMap(self) -> MapInfo: ...
    
    def GetMd5(self) -> str: ...

    def GetLineById(self, id: IdInfo) -> LineStringDataInfo: ...

    def GetLaneById(self, id: IdInfo) -> LaneInfo: ...

    def GetRoadById(self, id: IdInfo) -> RoadInfo: ...

    def GetJunctionById(self, id: IdInfo) -> JunctionInfo: ...

    def GetCrosswalkById(self, id: IdInfo) -> CrosswalkInfo: ...

    def GetStopLineById(self, id: IdInfo) -> StopLineInfo: ...

    def GetSignalById(self, id: IdInfo) -> SignalInfo: ...

    def GetPullOverRegionById(self, id: IdInfo) -> PullOverRegionInfo: ...

    def GetParkingSpaceById(self, id: IdInfo) -> ParkingSpaceInfo: ...

    def GetPoiById(self, id: IdInfo) -> PoiInfo: ...

    def GetObjectById(self, id: IdInfo) -> ObjectInfo: ...

    def GetLanes(self, point: Vec2d, distance: float) -> List[LaneInfo]: ...

    def GetJunctions(self, point: Vec2d,
                     distance: float) -> List[JunctionInfo]: ...

    def GetCrosswalks(self, point: Vec2d,
                      distance: float) -> List[CrosswalkInfo]: ...

    def GetRoads(self, point: Vec2d, distance: float) -> List[RoadInfo]: ...

    def GetClearAreas(self, point: Vec2d,
                      distance: float) -> List[ObjectInfo]: ...

    def GetParkingSpaces(self, point: Vec2d,
                         distance: float) -> List[ParkingSpaceInfo]: ...

    def GetObjects(self, point: Vec2d,
                   distance: float) -> List[ObjectInfo]: ...

    def GetNearestLane(self, point: Vec2d) -> LaneInfo: ...

    def GetNearestJunction(self, point: Vec2d) -> JunctionInfo: ...

    def GetNearestCrosswalk(self, point: Vec2d) -> CrosswalkInfo: ...

    def GetNearestClearArea(self, point: Vec2d) -> ObjectInfo: ...

    def GetNearestParkingSpace(self, point: Vec2d) -> ParkingSpaceInfo: ...

    def GetNearestObject(self, point: Vec2d) -> ObjectInfo: ...

    def GetPoiByName(self, name: str) -> PoiInfo: ...

    def GetLanesInJunction(self, junction_id: IdInfo) -> List[LaneInfo]: ...

    def GetConnectingRoads(self, from_road_id: IdInfo,
                           to_road_id: IdInfo) -> List[RoadInfo]: ...

    def GetConnectingLanes(self, from_lane_id: IdInfo,
                           to_lane_id: IdInfo) -> List[LaneInfo]: ...

    def GetDrivingIntoJunctionLanes(
        self, junction_id: IdInfo) -> List[LanePoint]: ...

    def GetDrivingOutOfJunctionLanes(
        self, junction_id: IdInfo) -> List[LanePoint]: ...

    def GetEstimateGroundHeight(self, point: Vec2d) -> float: ...

    def GetForwardSignals(self, point: Vec2d,
                          distance: float) -> List[SignalInfo]: ...

    def GetPoisInObject(self, object_id: IdInfo) -> List[PoiInfo]: ...

    def GetDockJunctions(self) -> List[JunctionInfo]: ...
    
    def GetGirderDirections(self) -> List[GirderDisplay]: ...
    
    def GetPoiInfo(self, poi_id: IdInfo) -> tuple[List[Vec2d], Vec2d, float]: ...
    
    def GetTideBridgeInfo(self) -> tuple[List[int], List[int]]: ...
    
    def DecideTurnMode(self, vessel_head_s:float, vessel_tail_s:float, 
                       head_bridge:str, leave_bridge:str, is_head:bool, 
                       mode:str) -> bool: ...

class IdInfo:
    def __init__(self, id: int = 0) -> None: ...

    def to_string(self) -> str: ...

    def value(self) -> int: ...


class LaneIndexInfo:
    def road_id(self) -> int: ...

    def lane_section_index(self) -> int: ...

    def lane_index(self) -> int: ...


class LaneBoundaryTypeWithRange:
    def type(self) -> None: ...

    def color(self) -> None: ...

    def is_left(self) -> None: ...

    def is_right(self) -> None: ...

    def cross_allowed(self) -> None: ...


class AttributesInfo:
    def SetAttribute(self) -> None: ...

    def GetAttribute(self) -> None: ...

    def attributes(self) -> None: ...


class LineStringDataInfo:
    def id(self) -> IdInfo: ...

    def points(self) -> List[Vec2d]: ...

    def type(self) -> int: ...

    def color(self) -> int: ...

    def line_string_data_pb(self) -> str: ...


class LineStringInfo:
    def id(self) -> IdInfo: ...

    def is_reverse(self) -> bool: ...

    def type(self) -> int: ...

    def color(self) -> int: ...

    def front(self) -> Vec2d: ...

    def back(self) -> Vec2d: ...

    def begin(self) -> None: ...

    def end(self) -> None: ...

    def data(self) -> LineStringDataInfo: ...

    def GetReverseLineString(self) -> None: ...

    def Reverse(self) -> None: ...


class CurveInfo:
    def lines(self) -> None: ...

    def front(self) -> None: ...

    def back(self) -> None: ...

    def begin(self) -> None: ...

    def end(self) -> None: ...

    def GetReverseCurve(self) -> None: ...


class LaneLinkInfo:
    def from_lane(self) -> LaneInfo: ...

    def from_s(self) -> float: ...

    def to_lane(self) -> LaneInfo: ...

    def to_s(self) -> float: ...


class LaneInfo:
    def lane_pb(self) -> str: ...

    def id(self) -> IdInfo: ...

    def type(self) -> int: ...

    def turn_type(self) -> int: ...

    def max_speed_limit(self) -> float: ...

    def min_speed_limit(self) -> float: ...

    def prefer_speed_limit(self) -> float: ...

    def junction_id(self) -> IdInfo: ...

    def junction(self) -> JunctionInfo: ...

    def IsInJunction(self) -> bool: ...

    def left_boundary(self) -> CurveInfo: ...

    def left_boundary_types(self) -> List[LaneBoundaryTypeWithRange]: ...

    def GetLeftBoundaryType(self) -> int: ...

    def right_boundary(self) -> CurveInfo: ...

    def right_boundary_types(self) -> List[LaneBoundaryTypeWithRange]: ...

    def GetRightBoundaryType(self) -> int: ...

    def reference_line(self) -> ReferenceLine: ...

    def length(self) -> float: ...

    def successor_lane_links(self) -> List[LaneLinkInfo]: ...

    def predecessor_lane_links(self) -> List[LaneLinkInfo]: ...

    def left_neighbor_forward_lane(self) -> LaneInfo: ...

    def right_neighbor_forward_lane(self) -> LaneInfo: ...

    def bi_direction_lane(self) -> LaneIndo: ...

    def left_neighbor_reverse_lanes(self) -> List[LaneInfo]: ...

    def right_neighbor_reverse_lanes(self) -> List[LaneInfo]: ...

    def left_neighbor_forward_driving_lane(self) -> LaneInfo: ...

    def right_neighbor_forward_driving_lane(self) -> LaneInfo: ...

    def polygon(self) -> Polygon2d: ...

    def lane_section(self) -> LaneSectionInfo: ...

    def road(self) -> RoadInfo: ...

    def attributes(self) -> AttributesInfo: ...

    def lanes(self) -> List[RelationInfo]: ...

    def stop_lines(self) -> List[StopLineInfo]: ...

    def stop_line_overlaps(self) -> List[StopLineInfo]: ...

    def crosswalks(self) -> List[RelationInfo]: ...

    def pull_over_region_relations(self) -> List[RelationInfo]: ...

    def pois(self) -> List[RelationInfo]: ...

    def clear_areas(self) -> List[RelationInfo]: ...

    def pull_over_regions(self) -> List[PullOverRegionInfo]: ...

    def parking_spaces(self) -> List[ParkingSpaceInfo]: ...

    def objects(self) -> List[RelationInfo]: ...

    def lane_priority(self) -> int: ...

    def is_waiting_area(self) -> bool: ...

    def GetProjection(self, point: Vec2d) -> Tuple[float, float]: ...

    def GetPoint(self, s: float, d: float, point: Vec2d) -> None: ...

    def GetHeading(self, s: float) -> float: ...

    def GetWidth(self, s: float) -> Tuple[float, float]: ...


class LaneSectionInfo:
    def lane_section_pb(self) -> str: ...

    def lanes(self) -> List[LaneInfo]: ...

    def prev_lane_section(self) -> LaneSectionInfo: ...

    def next_lane_section(self) -> LaneSectionInfo: ...

    def road(self) -> RoadInfo: ...


class RoadInfo:
    def road_pb(self) -> str: ...

    def id(self) -> IdInfo: ...

    def lane_sections(self) -> List[LaneSectionInfo]: ...

    def junction(self) -> JunctionInfo: ...

    def IsInJunction(self) -> bool: ...

    def next_roads(self) -> List[RoadInfo]: ...

    def prev_roads(self) -> List[RoadInfo]: ...

    def prev_junction(self) -> JunctionInfo: ...

    def next_junction(self) -> JunctionInfo: ...

    def polygon(self) -> Polygon2d: ...

    def attributes(self) -> AttributesInfo: ...

    def name(self) -> str: ...

    def road_struct(self) -> RoadStructInfo: ...


class JunctionInfo:
    def junction_pb(self) -> str: ...

    def id(self) -> IdInfo: ...

    def polygon(self) -> Polygon2d: ...

    def name(self) -> str: ...

    def roads(self) -> List[RoadInfo]: ...

    def attributes(self) -> AttributesInfo: ...

    def is_virtual_junction(self) -> bool: ...


class CrosswalkInfo:
    def crosswalk_pb(self) -> str: ...

    def id(self) -> IdInfo: ...

    def left_boundary(self) -> CurveInfo: ...

    def right_boundary(self) -> CurveInfo: ...

    def polygon(self) -> Polygon2d: ...

    def attributes(self) -> AttributesInfo: ...

    def lanes(self) -> List[RelationInfo]: ...


class StopLineInfo:
    def stop_line_pb(self) -> str: ...

    def id(self) -> IdInfo: ...

    def curve(self) -> CurveInfo: ...

    def lanes(self) -> List[RelationInfo]: ...

    def signals(self) -> List[RelationInfo]: ...


class SignalInfo:
    def signal_pb(self) -> str: ...

    def id(self) -> IdInfo: ...

    def polygon(self) -> Polygon2d: ...

    def stop_lines(self) -> List[RelationInfo]: ...

    def signal_type(self) -> int: ...

    def combination_type(self) -> int: ...

    def signal_center(self) -> Vec2d: ...


class PullOverRegionInfo:
    def pull_over_region_pb(self) -> str: ...

    def id(self) -> IdInfo: ...

    def pois(self) -> List[RelationInfo]: ...

    def lane(self) -> LaneInfo: ...

    def start_s(self) -> float: ...

    def end_s(self) -> float: ...

    def d(self) -> float: ...


class ParkingSpaceInfo:
    def parking_space_pb(self) -> str: ...

    def id(self) -> IdInfo: ...

    def left_boundary(self) -> CurveInfo: ...

    def right_boundary(self) -> CurveInfo: ...

    def reference_line(self) -> ReferenceLine: ...

    def polygon(self) -> Polygon2d: ...

    def in_lanes(self) -> List[Tuple[LaneInfo, float]]: ...

    def out_lanes(self) -> List[Tuple[LaneInfo, float]]: ...

    def pois(self) -> List[RelationInfo]: ...


class PoiInfo:
    def poi_pb(self) -> str: ...

    def id(self) -> IdInfo: ...

    def type(self) -> int: ...

    def name(self) -> str: ...

    def lanes(self) -> List[RelationInfo]: ...

    def pull_over_regions(self) -> List[RelationInfo]: ...

    def parking_spaces(self) -> List[RelationInfo]: ...


class ObjectInfo:
    def object_pb(self) -> str: ...

    def id(self) -> IdInfo: ...

    def type(self) -> int: ...

    def polygon(self) -> Polygon2d: ...

    def height(self) -> float: ...

    def lanes(self) -> List[RelationInfo]: ...


class RelationInfo:
    def relation_pb(self) -> str: ...

    def this_id(self) -> IdInfo: ...

    def this_lane_overlap_range(self) -> Range: ...

    def other_id(self) -> IdInfo: ...

    def other_lane_overlap_range(self) -> Range: ...


class RoadStructInfo:
    def road_struct_pb(self) -> str: ...

    def road_name(self) -> str: ...

    def road(self) -> RoadInfo: ...

    def GetLaneIndexById(self, id: IdInfo) -> LaneIndexInfo: ...


class MapInfo:

    def lines(self) -> List[LineStringDataInfo]: ...

    def lanes(self) -> List[LaneInfo]: ...

    def roads(self) -> List[RoadInfo]: ...

    def junctions(self) -> List[JunctionInfo]: ...

    def crosswalks(self) -> List[CrosswalkInfo]: ...

    def stop_lines(self) -> List[StopLineInfo]: ...

    def parking_spaces(self) -> List[ParkingSpaceInfo]: ...

    def pull_over_regions(self) -> List[PullOverRegionInfo]: ...

    def pois(self) -> List[PoiInfo]: ...

    def objects(self) -> List[ObjectInfo]: ...

    def lane_links(self) -> List[LaneLinkInfo]: ...

    def relations(self) -> List[RelationInfo]: ...

    def road_structs(self) -> List[RoadStructInfo]: ...

    def clear(self) -> None: ...


class Range:

    def __init__(self, start, end) -> None: ...

    def start(self) -> float: ...

    def end(self) -> float: ...

    def length(self) -> float: ...

    def Contains(self, value: float) -> bool: ...


class ReferencePoint:

    def __init__(self, x, y, heading, kappa, dkappa, s) -> None: ...

    def s(self) -> float: ...

    def kappa(self) -> float: ...

    def dkappa(self) -> float: ...

    def heading(self) -> float: ...

    def set_s(self, s: float) -> None: ...

    def DebugString(self) -> str: ...


class ReferenceLine:

    def __init__(self, reference_points: List[ReferencePoint]) -> None: ...

    def Stitch(self, other: ReferenceLine,
               start_s: float, end_s: float) -> bool: ...

    def reference_points(self) -> List[ReferencePoint]: ...

    def segments(self) -> List[LineSegment2d]: ...

    def GetReferencePoint(self, s) -> ReferencePoint: ...

    def SDToXY(self, sd_point: SDPoint, xy_point: Vec2d) -> None: ...

    def XYToSD(self, xy_point: Vec2d, sd_point: SDPoint) -> None: ...

    def Translate(self, d) -> None: ...

    def length(self) -> float: ...

    def curve_degree(self) -> float: ...

    def min_curvature_radius(self) -> float: ...

    def min_curvature_radius_s(self) -> float: ...

    def DebugString(self) -> str: ...

    def InitKDTree(self) -> None: ...


class OneExtendConfig:
    def __init__(self) -> None: ...

    @property
    def extend_dist(self) -> float: ...

    @property
    def has_extend_radius(self) -> bool: ...

    @property
    def extend_radius(self) -> float: ...

    @property
    def has_extend_rotate_angle(self) -> bool: ...

    @property
    def extend_rotate_angle(self) -> float: ...


class BezierConfig:
    def __init__(self) -> None: ...

    @property
    def bezier_dist_ratio_from_first(self) -> float: ...

    @property
    def bezier_dist_ratio_from_second(self) -> float: ...

    @property
    def bezier_dist_ratio_to_first(self) -> float: ...

    @property
    def bezier_dist_ratio_to_second(self) -> float: ...


class BlockLane:
    def __init__(self, lane_id: str, start_s: float, end_s: float) -> None: ...

    @property
    def lane_id(self) -> str: ...

    @property
    def start_s(self) -> float: ...

    @property
    def end_s(self) -> float: ...


class HdmapVessel:
    def __init__(self, vessel_uuid: str, head_s: float,
                 rear_s: float) -> None: ...

    @property
    def vessel_uuid(self) -> str: ...

    @property
    def head_s(self) -> float: ...

    @property
    def rear_s(self) -> float: ...

class BridgeMode:
    def __init__(self, bridge_name: str, mode: int) -> None: ...

    @property
    def bridge_name(self) -> str: ...
    
    @property
    def mode(self) -> int: ...

class CloudServiceVessel:
    def __init__(self)  -> None: ...
    
    @property
    def uuid(self) -> str: ...
    
    def set_uuid(self) -> None: ...
    
class GirderStatus:
    def __init__(self, has_this_area: bool, start_s: float,
                 end_s: float, girder_direction: int) -> None: ...

    @property
    def has_this_area(self) -> bool: ...

    @property
    def start_s(self) -> float: ...

    @property
    def end_s(self) -> float: ...
    
    @property
    def girder_direction(self) -> int: ...
    
class GirderAffect:
    
    def __init__(self, affect_level: int, affect_uuid: str, 
                 affect_direction: int) -> None: ...
    
    @property
    def affect_level(self) -> int: ...
    
    @property
    def affect_uuid(self) -> str: ...
    
    @property
    def affect_direction(self) ->int: ...
    
class GirderDisplay:
    
    def __init__(self) -> None: ...
    
    @property
    def polygon_points(self) -> List[Vec2d]: ...
    
    @property
    def center_point(self) -> Vec2d: ...
    
    @property
    def heading(self) -> float: ...

class Utils:
    @staticmethod
    def FitOneVirtualReferenceLine(
        from_reference_line: ReferenceLine, to_reference_line: ReferenceLine,
        lane_turn_type: int, from_extend: OneExtendConfig, to_extend: OneExtendConfig, bezier_config: BezierConfig,
        virtual_reference_line: ReferenceLine, show_debug: bool) -> bool: ...

    @staticmethod
    def BuildCentralReferenceLine(left_marking_line_bytes: str, right_marking_line_bytes: str,
                                  need_smooth: bool, reference_line: ReferenceLine) -> bool: ...

    @staticmethod
    def SetReferenceLineSmootherConfig(smoother_config_bytes: str) -> None: ...

    @staticmethod
    def BuildReferenceLineFromPoints(
        self, points: List[Vec2d], reference_line: ReferenceLine) -> bool: ...

    @staticmethod
    def GetBoundaryLineSegments(
        one_lane: LaneInfo, one_line_segments: list[LineSegment2d]) -> list[LineSegment2d]: ...

    @staticmethod
    def ShrinkLineSegments(
        one_line_segments: list[LineSegment2d]) -> list[LineSegment2d]: ...

    @staticmethod
    def GetLineSegmentsIntersectPolygon(one_line_segments: list[LineSegment2d],
                                        one_ref_line: ReferenceLine, anther_polygon: Polygon2d) -> list[(float, float)]: ...

    @staticmethod
    def BuildPointsFromCurve(curve_info: CurveInfo,
                             points: list[Vec2d]) -> None: ...
