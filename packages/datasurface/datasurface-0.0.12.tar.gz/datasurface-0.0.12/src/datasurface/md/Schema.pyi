import abc
from .Documentation import Documentable as Documentable, Documentation as Documentation
from .Lint import ValidationTree as ValidationTree
from .utils import ANSI_SQL_NamedObject as ANSI_SQL_NamedObject, is_valid_sql_identifier as is_valid_sql_identifier
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from datasurface.md.Policy import DataClassification as DataClassification, DataClassificationPolicy as DataClassificationPolicy
from enum import Enum
from typing import Optional, Union

class DataType(ABC, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    @abstractmethod
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...
    @abstractmethod
    def lint(self, vTree: ValidationTree) -> None: ...

class BoundedDataType(DataType):
    maxSize: Incomplete
    def __init__(self, maxSize: Optional[int]) -> None: ...
    def lint(self, vTree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class TextDataType(BoundedDataType):
    collationString: Incomplete
    def __init__(self, maxSize: Optional[int], collationString: Optional[str]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class NumericDataType(DataType, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class SignedOrNot(Enum):
    SIGNED: int
    UNSIGNED: int

class FixedSizeBinaryDataType(NumericDataType):
    sizeInBits: Incomplete
    isSigned: Incomplete
    def __init__(self, sizeInBits: int, isSigned: SignedOrNot) -> None: ...
    def lint(self, vTree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class TinyInt(FixedSizeBinaryDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class SmallInt(FixedSizeBinaryDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class Integer(FixedSizeBinaryDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class BigInt(FixedSizeBinaryDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class NonFiniteBehavior(Enum):
    IEEE754: int
    NanOnly: int

class FloatNanEncoding(Enum):
    IEEE: int
    AllOnes: int
    NegativeZero: int

class CustomFloat(NumericDataType):
    sizeInBits: Incomplete
    maxExponent: Incomplete
    minExponent: Incomplete
    precision: Incomplete
    nonFiniteBehavior: Incomplete
    nanEncoding: Incomplete
    def __init__(self, maxExponent: int, minExponent: int, precision: int, sizeInBits: int, nonFiniteBehavior: NonFiniteBehavior = ..., nanEncoding: FloatNanEncoding = ...) -> None: ...
    def lint(self, vTree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isRepresentableBy(self, other: CustomFloat) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class IEEE16(CustomFloat):
    def __init__(self) -> None: ...

class IEEE32(CustomFloat):
    def __init__(self) -> None: ...

class Float(IEEE32):
    def __init__(self) -> None: ...

class IEEE64(CustomFloat):
    def __init__(self) -> None: ...

class Double(IEEE64):
    def __init__(self) -> None: ...

class IEEE128(CustomFloat):
    def __init__(self) -> None: ...

class IEEE256(CustomFloat):
    def __init__(self) -> None: ...

class FP8_E4M3(CustomFloat):
    def __init__(self) -> None: ...

class FP8_E5M2(CustomFloat):
    def __init__(self) -> None: ...

class FP8_E5M2FNUZ(CustomFloat):
    def __init__(self) -> None: ...

class FP8_E4M3FNUZ(CustomFloat):
    def __init__(self) -> None: ...

class Decimal(BoundedDataType):
    precision: Incomplete
    def __init__(self, maxSize: int, precision: int) -> None: ...
    def lint(self, vTree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class TemporalDataType(DataType, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, vTree: ValidationTree) -> None: ...

class Timestamp(TemporalDataType):
    def __init__(self) -> None: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class Date(TemporalDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class Interval(TemporalDataType):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class UniCodeType(TextDataType):
    def __init__(self, maxSize: Optional[int], collationString: Optional[str]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class NonUnicodeString(TextDataType):
    def __init__(self, maxSize: Optional[int], collationString: Optional[str]) -> None: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class VarChar(NonUnicodeString):
    def __init__(self, maxSize: Optional[int] = None, collationString: Optional[str] = None) -> None: ...

class NVarChar(UniCodeType):
    def __init__(self, maxSize: Optional[int] = None, collationString: Optional[str] = None) -> None: ...

class String(NVarChar):
    def __init__(self, maxSize: Optional[int] = None, collationString: Optional[str] = None) -> None: ...

def strForFixedSizeString(clsName: str, maxSize: int, collationString: Optional[str]) -> str: ...

class Char(TextDataType):
    def __init__(self, maxSize: int = 1, collationString: Optional[str] = None) -> None: ...

class NChar(UniCodeType):
    def __init__(self, maxSize: int = 1, collationString: Optional[str] = None) -> None: ...

class Boolean(DataType):
    def __init__(self) -> None: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...
    def lint(self, vTree: ValidationTree) -> None: ...

class Variant(BoundedDataType):
    def __init__(self, maxSize: Optional[int] = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class Binary(BoundedDataType):
    def __init__(self, maxSize: Optional[int] = None) -> None: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class Vector(DataType):
    dimensions: Incomplete
    def __init__(self, dimensions: int) -> None: ...
    def lint(self, vTree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: DataType, vTree: ValidationTree) -> bool: ...

class NullableStatus(Enum):
    NOT_NULLABLE: int
    NULLABLE: int

class PrimaryKeyStatus(Enum):
    NOT_PK: int
    PK: int

DEFAULT_primaryKey: PrimaryKeyStatus
DEFAULT_nullable: NullableStatus

class DDLColumn(ANSI_SQL_NamedObject, Documentable):
    type: Incomplete
    primaryKey: Incomplete
    classification: Incomplete
    nullable: Incomplete
    documentation: Incomplete
    def __init__(self, name: str, dataType: DataType, *args: Union[NullableStatus, DataClassification, PrimaryKeyStatus, Documentation]) -> None: ...
    def __eq__(self, o: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: object, vTree: ValidationTree) -> bool: ...
    def lint(self, tree: ValidationTree) -> None: ...

class AttributeList:
    colNames: Incomplete
    def __init__(self, colNames: list[str]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, tree: ValidationTree) -> None: ...

class PrimaryKeyList(AttributeList):
    def __init__(self, colNames: list[str]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class PartitionKeyList(AttributeList):
    def __init__(self, colNames: list[str]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class Schema(ABC, Documentable, metaclass=abc.ABCMeta):
    primaryKeyColumns: Incomplete
    ingestionPartitionColumns: Incomplete
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    @abstractmethod
    def getHubSchema(self) -> Schema: ...
    @abstractmethod
    def isBackwardsCompatibleWith(self, other: Schema, vTree: ValidationTree) -> bool: ...
    @abstractmethod
    def checkClassificationsAreOnly(self, verifier: DataClassificationPolicy) -> bool: ...
    @abstractmethod
    def hasDataClassifications(self) -> bool: ...
    @abstractmethod
    def lint(self, tree: ValidationTree) -> None: ...

class DDLTable(Schema):
    columns: Incomplete
    def __init__(self, *args: Union[DDLColumn, PrimaryKeyList, PartitionKeyList, Documentation]) -> None: ...
    def hasDataClassifications(self) -> bool: ...
    def checkClassificationsAreOnly(self, verifier: DataClassificationPolicy) -> bool: ...
    primaryKeyColumns: Incomplete
    ingestionPartitionColumns: Incomplete
    documentation: Incomplete
    def add(self, *args: Union[DDLColumn, PrimaryKeyList, PartitionKeyList, Documentation]): ...
    def calculateKeys(self) -> None: ...
    def getHubSchema(self) -> Schema: ...
    def getColumnByName(self, name: str) -> Optional[DDLColumn]: ...
    def __eq__(self, o: object) -> bool: ...
    def isBackwardsCompatibleWith(self, other: Schema, vTree: ValidationTree) -> bool: ...
    def lint(self, tree: ValidationTree) -> None: ...
