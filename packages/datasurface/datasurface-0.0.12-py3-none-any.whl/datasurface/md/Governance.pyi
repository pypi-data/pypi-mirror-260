import abc
from .Documentation import Documentable as Documentable, Documentation as Documentation
from .Exceptions import AttributeAlreadySetException as AttributeAlreadySetException, DatastoreDoesntExistException as DatastoreDoesntExistException, ObjectAlreadyExistsException as ObjectAlreadyExistsException, ObjectDoesntExistException as ObjectDoesntExistException, UnknownArgumentException as UnknownArgumentException, WorkspaceDoesntExistException as WorkspaceDoesntExistException
from .Lint import AttributeNotSet as AttributeNotSet, ConstraintViolation as ConstraintViolation, DataTransformerMissing as DataTransformerMissing, DuplicateObject as DuplicateObject, NameMustBeSQLIdentifier as NameMustBeSQLIdentifier, ObjectIsDeprecated as ObjectIsDeprecated, ObjectMissing as ObjectMissing, ObjectNotCompatibleWithPolicy as ObjectNotCompatibleWithPolicy, ObjectWrongType as ObjectWrongType, ProblemSeverity as ProblemSeverity, ProductionDatastoreMustHaveClassifications as ProductionDatastoreMustHaveClassifications, UnauthorizedAttributeChange as UnauthorizedAttributeChange, UnknownObjectReference as UnknownObjectReference, ValidationTree as ValidationTree
from .Schema import DataClassification as DataClassification, DataClassificationPolicy as DataClassificationPolicy, Schema as Schema
from .utils import ANSI_SQL_NamedObject as ANSI_SQL_NamedObject, is_valid_hostname_or_ip as is_valid_hostname_or_ip, is_valid_sql_identifier as is_valid_sql_identifier, validate_cron_string as validate_cron_string
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datasurface.md.GitOps import GitControlledObject as GitControlledObject, Repository as Repository
from datasurface.md.Policy import AllowDisallowPolicy as AllowDisallowPolicy, Policy as Policy
from datetime import timedelta
from enum import Enum
from typing import Callable, Generic, Optional, Sequence, TypeVar, Union

class ProductionStatus(Enum):
    PRODUCTION: int
    NOT_PRODUCTION: int

class DeprecationStatus(Enum):
    NOT_DEPRECATED: int
    DEPRECATED: int

class DeprecationInfo(Documentable):
    status: Incomplete
    def __init__(self, status: DeprecationStatus, reason: Optional[Documentation] = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

def cyclic_safe_eq(a: object, b: object, visited: set[object]) -> bool: ...

class GenericKey(ABC):
    def __hash__(self) -> int: ...

class EcosystemKey(GenericKey):
    ecoName: Incomplete
    def __init__(self, ecoName: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class GovernanceZoneKey(EcosystemKey):
    gzName: Incomplete
    def __init__(self, e: EcosystemKey, gz: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class StoragePolicyKey(GovernanceZoneKey):
    policyName: Incomplete
    def __init__(self, gz: GovernanceZoneKey, policyName: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class InfrastructureVendorKey(EcosystemKey):
    ivName: Incomplete
    def __init__(self, eco: EcosystemKey, iv: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class InfraLocationKey(InfrastructureVendorKey):
    locationPath: Incomplete
    def __init__(self, iv: InfrastructureVendorKey, loc: list[str]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...

class TeamDeclarationKey(GovernanceZoneKey):
    tdName: Incomplete
    def __init__(self, gz: GovernanceZoneKey, td: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class WorkspaceKey(TeamDeclarationKey):
    name: Incomplete
    def __init__(self, tdKey: TeamDeclarationKey, name: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class DatastoreKey(TeamDeclarationKey):
    dsName: Incomplete
    def __init__(self, td: TeamDeclarationKey, ds: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class PolicyMandatedRule(Enum):
    MANDATED_WITHIN_ZONE: int
    INDIVIDUALLY_MANDATED: int

class StoragePolicy(Policy['DataContainer']):
    mandatory: Incomplete
    key: Incomplete
    deprecationStatus: Incomplete
    def __init__(self, name: str, isMandatory: PolicyMandatedRule, doc: Optional[Documentation], deprecationStatus: DeprecationInfo) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def setGovernanceZone(self, gz: GovernanceZone) -> None: ...
    def isCompatible(self, obj: DataContainer) -> bool: ...

class StoragePolicyAllowAnyContainer(StoragePolicy):
    def __init__(self, name: str, isMandatory: PolicyMandatedRule, doc: Optional[Documentation] = None, deprecationStatus: DeprecationInfo = ...) -> None: ...
    def isCompatible(self, obj: DataContainer) -> bool: ...
    def __eq__(self, __value: object) -> bool: ...

class InfrastructureLocation(Documentable):
    name: Incomplete
    key: Incomplete
    locations: Incomplete
    def __init__(self, name: str, *args: Union[Documentation, 'InfrastructureLocation']) -> None: ...
    def __hash__(self) -> int: ...
    def lint(self, tree: ValidationTree): ...
    def setParentLocation(self, parent: InfraLocationKey) -> None: ...
    documentation: Incomplete
    def add(self, *args: Union[Documentation, 'InfrastructureLocation']) -> None: ...
    def addLocation(self, loc: InfrastructureLocation): ...
    def __eq__(self, __value: object) -> bool: ...
    def getEveryChildLocation(self) -> set['InfrastructureLocation']: ...
    def getLocationOrThrow(self, locationName: str) -> InfrastructureLocation: ...
    def getLocation(self, locationName: str) -> Optional['InfrastructureLocation']: ...
    def findLocationUsingKey(self, locationPath: list[str]) -> Optional['InfrastructureLocation']: ...

class CloudVendor(Enum):
    AWS: int
    AZURE: int
    GCP: int
    IBM: int
    ORACLE: int
    ALIBABA: int
    AWS_CHINA: int
    TEN_CENT: int
    HUAWEI: int
    AZURE_CHINA: int

class InfrastructureVendor(Documentable):
    name: Incomplete
    key: Incomplete
    locations: Incomplete
    hardCloudVendor: Incomplete
    def __init__(self, name: str, *args: Union[InfrastructureLocation, Documentation, CloudVendor]) -> None: ...
    def __hash__(self) -> int: ...
    def setEcosystem(self, eco: Ecosystem) -> None: ...
    documentation: Incomplete
    def add(self, *args: Union['InfrastructureLocation', Documentation, CloudVendor]) -> None: ...
    def addLocation(self, loc: InfrastructureLocation): ...
    def __eq__(self, __value: object) -> bool: ...
    def getLocationOrThrow(self, locationName: str) -> InfrastructureLocation: ...
    def getLocation(self, locationName: str) -> Optional['InfrastructureLocation']: ...
    def findLocationUsingKey(self, locationPath: list[str]) -> Optional[InfrastructureLocation]: ...
    def lint(self, tree: ValidationTree): ...

class InfraStructureVendorPolicy(AllowDisallowPolicy[InfrastructureVendor]):
    def __init__(self, name: str, doc: Documentation, allowed: Optional[set[InfrastructureVendor]] = None, notAllowed: Optional[set[InfrastructureVendor]] = None) -> None: ...
    def __eq__(self, v: object) -> bool: ...
    def __hash__(self) -> int: ...

class InfraHardVendorPolicy(AllowDisallowPolicy[CloudVendor]):
    def __init__(self, name: str, doc: Documentation, allowed: Optional[set[CloudVendor]] = None, notAllowed: Optional[set[CloudVendor]] = None) -> None: ...
    def __eq__(self, v: object) -> bool: ...
    def __hash__(self) -> int: ...

class InfraStructureLocationPolicy(AllowDisallowPolicy[InfrastructureLocation]):
    def __init__(self, name: str, doc: Documentation, allowed: Optional[set[InfrastructureLocation]] = None, notAllowed: Optional[set[InfrastructureLocation]] = None) -> None: ...
    def __eq__(self, v: object) -> bool: ...
    def __hash__(self) -> int: ...

class DataPlatformPolicy(AllowDisallowPolicy['DataPlatform']):
    def __init__(self, name: str, doc: Optional[Documentation], allowed: Optional[set['DataPlatform']] = None, notAllowed: Optional[set['DataPlatform']] = None) -> None: ...
    def __eq__(self, v: object) -> bool: ...
    def __hash__(self) -> int: ...

class EncryptionSystem:
    name: Incomplete
    keyContainer: Incomplete
    hasThirdPartySuperUser: bool
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class DataContainer(ABC, Documentable, metaclass=abc.ABCMeta):
    locations: Incomplete
    name: Incomplete
    serverSideEncryptionKeys: Incomplete
    clientSideEncryptionKeys: Incomplete
    isReadOnly: bool
    def __init__(self, name: str, *args: Union[InfrastructureLocation, Documentation]) -> None: ...
    documentation: Incomplete
    def add(self, *args: Union[InfrastructureLocation, Documentation]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def getName(self) -> str: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, tree: ValidationTree) -> None: ...
    def __hash__(self) -> int: ...
    def isUsingVendorsOnly(self, eco: Ecosystem, vendors: set[CloudVendor]) -> bool: ...

class SQLDatabase(DataContainer):
    databaseName: Incomplete
    def __init__(self, name: str, location: InfrastructureLocation, databaseName: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, tree: ValidationTree) -> None: ...

class URLSQLDatabase(SQLDatabase):
    url: Incomplete
    def __init__(self, name: str, location: InfrastructureLocation, url: str, databaseName: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class HostPortSQLDatabase(SQLDatabase):
    host: Incomplete
    port: Incomplete
    def __init__(self, name: str, location: InfrastructureLocation, host: str, port: int, databaseName: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, tree: ValidationTree) -> None: ...

class ObjectStorage(DataContainer, metaclass=abc.ABCMeta):
    endPointURI: Incomplete
    bucketName: Incomplete
    prefix: Incomplete
    def __init__(self, name: str, loc: InfrastructureLocation, endPointURI: Optional[str], bucketName: str, prefix: Optional[str]) -> None: ...

class Dataset(ANSI_SQL_NamedObject, Documentable):
    originalSchema: Incomplete
    policies: Incomplete
    dataClassificationOverride: Incomplete
    deprecationStatus: Incomplete
    def __init__(self, name: str, *args: Union[Schema, StoragePolicy, Documentation, DeprecationInfo, DataClassification]) -> None: ...
    documentation: Incomplete
    def add(self, *args: Union[Schema, StoragePolicy, Documentation, DeprecationInfo, DataClassification]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, store: Datastore, tree: ValidationTree) -> None: ...
    def checkClassificationsAreOnly(self, verifier: DataClassificationPolicy) -> bool: ...
    def isBackwardsCompatibleWith(self, other: object, vTree: ValidationTree) -> bool: ...
    def hasClassifications(self) -> bool: ...

class Credential(ABC, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class FileSecretCredential(Credential):
    secretFilePath: Incomplete
    def __init__(self, filePath: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class UserPasswordCredential(Credential):
    username: Incomplete
    password: Incomplete
    def __init__(self, username: str, password: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class ClearTextCredential(UserPasswordCredential):
    def __init__(self, username: str, password: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class PyOdbcSourceInfo(DataContainer):
    serverHost: Incomplete
    databaseName: Incomplete
    driver: Incomplete
    connectionStringTemplate: Incomplete
    def __init__(self, name: str, loc: InfrastructureLocation, serverHost: str, databaseName: str, driver: str, connectionStringTemplate: str) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, tree: ValidationTree) -> None: ...

class CaptureType(Enum):
    SNAPSHOT: int
    INCREMENTAL: int

class IngestionConsistencyType(Enum):
    SINGLE_DATASET: int
    MULTI_DATASET: int

class StepTrigger(ABC, metaclass=abc.ABCMeta):
    name: Incomplete
    def __init__(self, name: str) -> None: ...
    def __eq__(self, o: object) -> bool: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, tree: ValidationTree) -> None: ...

class CronTrigger(StepTrigger):
    cron: Incomplete
    def __init__(self, name: str, cron: str) -> None: ...
    def __eq__(self, o: object) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, tree: ValidationTree) -> None: ...

class CaptureMetaData(ABC, metaclass=abc.ABCMeta):
    singleOrMultiDatasetIngestion: Incomplete
    stepTrigger: Incomplete
    def __init__(self, stepTrigger: Optional[StepTrigger] = None) -> None: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, d: Datastore, tree: ValidationTree) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class DataTransformerOutput(CaptureMetaData):
    workSpaceName: Incomplete
    singleOrMultiDatasetIngestion: Incomplete
    def __init__(self, workSpaceName: str) -> None: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, d: Datastore, tree: ValidationTree) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class IngestionMetadata(CaptureMetaData, metaclass=abc.ABCMeta):
    credential: Incomplete
    dataContainer: Incomplete
    def __init__(self, dc: DataContainer, *args: Union[Credential, StepTrigger, IngestionConsistencyType]) -> None: ...
    stepTrigger: Incomplete
    singleOrMultiDatasetIngestion: Incomplete
    def add(self, *args: Union[Credential, StepTrigger, IngestionConsistencyType]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, d: Datastore, tree: ValidationTree) -> None: ...

class CDCCaptureIngestion(IngestionMetadata):
    def __init__(self, dc: DataContainer, *args: Union[Credential, StepTrigger, IngestionConsistencyType]) -> None: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, d: Datastore, tree: ValidationTree) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class SQLPullIngestion(IngestionMetadata):
    variableNames: Incomplete
    snapshotSQL: Incomplete
    deltaSQL: Incomplete
    def __init__(self, dc: DataContainer, *args: Union[Credential, StepTrigger, IngestionConsistencyType]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, d: Datastore, tree: ValidationTree) -> None: ...

class Datastore(ANSI_SQL_NamedObject, Documentable):
    datasets: Incomplete
    key: Incomplete
    cmd: Incomplete
    container: Incomplete
    productionStatus: Incomplete
    deprecationStatus: Incomplete
    def __init__(self, name: str, *args: Union[Dataset, CaptureMetaData, DataContainer, Documentation, ProductionStatus, DeprecationInfo]) -> None: ...
    def setTeam(self, tdKey: TeamDeclarationKey): ...
    documentation: Incomplete
    def add(self, *args: Union[Dataset, CaptureMetaData, DataContainer, Documentation, ProductionStatus, DeprecationInfo]) -> None: ...
    def isDatasetDeprecated(self, dataset: Dataset) -> bool: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, storeTree: ValidationTree) -> None: ...
    def isBackwardsCompatibleWith(self, other: object, vTree: ValidationTree) -> bool: ...

class TeamCacheEntry:
    team: Incomplete
    declaration: Incomplete
    def __init__(self, t: Team, td: TeamDeclaration) -> None: ...

class WorkspaceCacheEntry:
    workspace: Incomplete
    team: Incomplete
    def __init__(self, w: Workspace, t: Team) -> None: ...

class DatastoreCacheEntry:
    datastore: Incomplete
    team: Incomplete
    def __init__(self, d: Datastore, t: Team) -> None: ...

class DependentWorkspaces:
    workspace: Incomplete
    dependencies: Incomplete
    def __init__(self, workSpace: Workspace) -> None: ...
    def addDependency(self, dep: DependentWorkspaces) -> None: ...
    def flatten(self) -> set['Workspace']: ...
    def __hash__(self) -> int: ...
    def __eq__(self, __value: object) -> bool: ...

class DefaultDataPlatform:
    defaultPlatform: Incomplete
    def __init__(self, p: DataPlatform) -> None: ...

class Ecosystem(GitControlledObject):
    def createGZone(self, name: str, repo: Repository) -> GovernanceZone: ...
    name: Incomplete
    key: Incomplete
    zones: Incomplete
    vendors: Incomplete
    dataPlatforms: Incomplete
    defaultDataPlatform: Incomplete
    def __init__(self, name: str, repo: Repository, *args: Union['DataPlatform', Documentation, DefaultDataPlatform, InfrastructureVendor, 'GovernanceZoneDeclaration']) -> None: ...
    datastoreCache: Incomplete
    workSpaceCache: Incomplete
    teamCache: Incomplete
    def resetCaches(self) -> None: ...
    documentation: Incomplete
    def add(self, *args: Union['DataPlatform', DefaultDataPlatform, Documentation, InfrastructureVendor, 'GovernanceZoneDeclaration']) -> None: ...
    def getDefaultDataPlatform(self) -> DataPlatform: ...
    def getVendor(self, name: str) -> Optional[InfrastructureVendor]: ...
    def getVendorOrThrow(self, name: str) -> InfrastructureVendor: ...
    def getDataPlatform(self, name: str) -> Optional['DataPlatform']: ...
    def getDataPlatformOrThrow(self, name: str) -> DataPlatform: ...
    def getLocation(self, vendorName: str, locKey: list[str]) -> Optional[InfrastructureLocation]: ...
    def getLocationOrThrow(self, vendorName: str, locKey: list[str]) -> InfrastructureLocation: ...
    def getAllChildLocations(self, vendorName: str, locKey: list[str]) -> set[InfrastructureLocation]: ...
    def cache_addTeam(self, td: TeamDeclaration, t: Team): ...
    def cache_addWorkspace(self, team: Team, work: Workspace): ...
    def cache_addDatastore(self, store: Datastore, t: Team): ...
    def cache_getWorkspaceOrThrow(self, work: str) -> WorkspaceCacheEntry: ...
    def cache_getDatastoreOrThrow(self, store: str) -> DatastoreCacheEntry: ...
    def cache_getDataset(self, storeName: str, datasetName: str) -> Optional[Dataset]: ...
    def lintAndHydrateCaches(self) -> ValidationTree: ...
    def calculateDependenciesForDatastore(self, storeName: str, wsVisitedSet: set[str] = ...) -> Sequence[DependentWorkspaces]: ...
    def checkIfChangesAreAuthorized(self, proposed: GitControlledObject, changeSource: Repository, vTree: ValidationTree) -> None: ...
    def __eq__(self, proposed: object) -> bool: ...
    def areTopLevelChangesAuthorized(self, proposed: GitControlledObject, changeSource: Repository, tree: ValidationTree) -> bool: ...
    def getZone(self, gz: str) -> Optional['GovernanceZone']: ...
    def getZoneOrThrow(self, gz: str) -> GovernanceZone: ...
    def getTeam(self, gz: str, teamName: str) -> Optional['Team']: ...
    def getTeamOrThrow(self, gz: str, teamName: str) -> Team: ...
    def checkIfChangesAreBackwardsCompatibleWith(self, originEco: Ecosystem, vTree: ValidationTree) -> None: ...
    def checkIfChangesCanBeMerged(self, proposed: Ecosystem, source: Repository) -> ValidationTree: ...

class Team(GitControlledObject):
    name: Incomplete
    workspaces: Incomplete
    dataStores: Incomplete
    def __init__(self, name: str, repo: Repository, *args: Union[Datastore, 'Workspace', Documentation]) -> None: ...
    documentation: Incomplete
    def add(self, *args: Union[Datastore, 'Workspace', Documentation]) -> None: ...
    def addStore(self, store: Datastore): ...
    def addWorkspace(self, w: Workspace): ...
    def __eq__(self, __value: object) -> bool: ...
    def getStoreOrThrow(self, storeName: str) -> Datastore: ...
    def areTopLevelChangesAuthorized(self, proposed: GitControlledObject, changeSource: Repository, tree: ValidationTree) -> bool: ...
    def checkIfChangesAreAuthorized(self, proposed: GitControlledObject, changeSource: Repository, vTree: ValidationTree) -> None: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, td: TeamDeclaration, teamTree: ValidationTree) -> None: ...
    def isBackwardsCompatibleWith(self, originTeam: Team, vTree: ValidationTree): ...

class NamedObjectAuthorization:
    name: Incomplete
    owningRepo: Incomplete
    def __init__(self, name: str, owningRepo: Repository) -> None: ...
    def lint(self, tree: ValidationTree): ...
    def __eq__(self, __value: object) -> bool: ...
G = TypeVar('G', bound=GitControlledObject)
N = TypeVar('N', bound=NamedObjectAuthorization)

class AuthorizedObjectManager(GitControlledObject, Generic[G, N]):
    name: Incomplete
    authorizedNames: Incomplete
    authorizedObjects: Incomplete
    factory: Incomplete
    def __init__(self, name: str, factory: Callable[[str, Repository], G], owningRepo: Repository) -> None: ...
    def getNumObjects(self) -> int: ...
    def addAuthorization(self, t: N): ...
    def defineAllObjects(self) -> None: ...
    def getObject(self, name: str) -> Optional[G]: ...
    def __eq__(self, __value: object) -> bool: ...
    def areTopLevelChangesAuthorized(self, proposed: GitControlledObject, changeSource: Repository, tree: ValidationTree) -> bool: ...
    def checkIfChangesAreAuthorized(self, proposed: GitControlledObject, changeSource: Repository, vTree: ValidationTree) -> None: ...
    def removeAuthorization(self, name: str) -> Optional[N]: ...
    def removeDefinition(self, name: str) -> Optional[G]: ...
    def lint(self, tree: ValidationTree): ...

class TeamDeclaration(NamedObjectAuthorization):
    authRepo: Incomplete
    key: Incomplete
    def __init__(self, name: str, authRepo: Repository) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def setGovernanceZone(self, gz: GovernanceZone) -> None: ...

class GovernanceZoneDeclaration(NamedObjectAuthorization):
    key: Incomplete
    def __init__(self, name: str, authRepo: Repository) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class GovernanceZone(GitControlledObject):
    name: Incomplete
    key: Incomplete
    teams: Incomplete
    storagePolicies: Incomplete
    classificationPolicies: Incomplete
    vendorPolicies: Incomplete
    hardVendorPolicies: Incomplete
    locationPolicies: Incomplete
    dataplatformPolicies: Incomplete
    def __init__(self, name: str, ownerRepo: Repository, *args: Union[InfraStructureLocationPolicy, InfraStructureVendorPolicy, StoragePolicy, DataClassificationPolicy, TeamDeclaration, Documentation, DataPlatformPolicy, InfraHardVendorPolicy]) -> None: ...
    def setEcosystem(self, eco: Ecosystem) -> None: ...
    def checkLocationIsAllowed(self, eco: Ecosystem, loc: InfrastructureLocation, tree: ValidationTree): ...
    documentation: Incomplete
    def add(self, *args: Union[InfraStructureVendorPolicy, InfraStructureLocationPolicy, StoragePolicy, DataClassificationPolicy, TeamDeclaration, DataPlatformPolicy, Documentation, InfraHardVendorPolicy]) -> None: ...
    def getTeam(self, name: str) -> Optional[Team]: ...
    def getTeamOrThrow(self, name: str) -> Team: ...
    def __eq__(self, __value: object) -> bool: ...
    def areTopLevelChangesAuthorized(self, proposed: GitControlledObject, changeSource: Repository, tree: ValidationTree) -> bool: ...
    def checkIfChangesAreAuthorized(self, proposed: GitControlledObject, changeSource: Repository, vTree: ValidationTree) -> None: ...
    def lint(self, eco: Ecosystem, govTree: ValidationTree) -> None: ...
    def isBackwardsCompatibleWith(self, originZone: GovernanceZone, tree: ValidationTree): ...
    def getDatasetStoragePolicies(self, dataset: Dataset) -> Sequence[StoragePolicy]: ...

@dataclass
class WorkspaceEntitlement: ...
@dataclass
class EventSink: ...
@dataclass
class Deliverable: ...

class DataPlatform(ABC, Documentable, metaclass=abc.ABCMeta):
    name: Incomplete
    def __init__(self, name: str, doc: Documentation) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...
    @abstractmethod
    def getInternalDataContainers(self) -> set[DataContainer]: ...
    @abstractmethod
    def getSupportedVendors(self, eco: Ecosystem) -> set[InfrastructureVendor]: ...
    @abstractmethod
    def isContainerSupported(self, eco: Ecosystem, dc: DataContainer) -> bool: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, tree: ValidationTree): ...

class DataLatency(Enum):
    SECONDS: int
    MINUTES: int
    HOURS: int
    DAYS: int

class DataRetentionPolicy(Enum):
    LIVE_ONLY: int
    FORENSIC: int
    LIVE_WITH_FORENSIC_HISTORY: int

class ConsumerRetentionRequirements:
    policy: Incomplete
    latency: Incomplete
    minRetentionTime: Incomplete
    regulator: Incomplete
    def __init__(self, r: DataRetentionPolicy, latency: DataLatency, regulator: Optional[str], minRetentionDurationIfNeeded: Optional[timedelta] = None) -> None: ...
    def __eq__(self, __value: object) -> bool: ...

class DataPlatformChooser(ABC, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    @abstractmethod
    def choooseDataPlatform(self, eco: Ecosystem) -> Optional[DataPlatform]: ...

class FixedDataPlatform(DataPlatformChooser):
    fixedDataPlatform: Incomplete
    def __init__(self, dp: DataPlatform) -> None: ...
    def choooseDataPlatform(self, eco: Ecosystem) -> Optional[DataPlatform]: ...
    def __eq__(self, __value: object) -> bool: ...

class WorkspacePlatformConfig(DataPlatformChooser):
    retention: Incomplete
    def __init__(self, hist: ConsumerRetentionRequirements) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def choooseDataPlatform(self, eco: Ecosystem) -> Optional[DataPlatform]: ...

class WorkspaceFixedDataPlatform(DataPlatformChooser):
    dataPlatform: Incomplete
    def __init__(self, dp: DataPlatform) -> None: ...
    def __eq__(self, o: object) -> bool: ...
    def choooseDataPlatform(self, eco: Ecosystem) -> Optional[DataPlatform]: ...

class DeprecationsAllowed(Enum):
    NEVER: int
    ALLOWED: int

class DatasetSink:
    storeName: Incomplete
    datasetName: Incomplete
    key: Incomplete
    deprecationsAllowed: Incomplete
    def __init__(self, storeName: str, datasetName: str, deprecationsAllowed: DeprecationsAllowed = ...) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def __hash__(self) -> int: ...
    def lint(self, eco: Ecosystem, team: Team, ws: Workspace, tree: ValidationTree): ...

class DatasetGroup(ANSI_SQL_NamedObject, Documentable):
    platformMD: Incomplete
    sinks: Incomplete
    documentation: Incomplete
    def __init__(self, name: str, *args: Union[DatasetSink, WorkspacePlatformConfig, Documentation]) -> None: ...
    def __eq__(self, __value: object) -> bool: ...
    def lint(self, eco: Ecosystem, team: Team, ws: Workspace, tree: ValidationTree): ...

class TransformerTrigger:
    name: Incomplete
    def __init__(self, name: str) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class TimedTransformerTrigger(TransformerTrigger):
    trigger: Incomplete
    def __init__(self, name: str, transformerTrigger: StepTrigger) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class CodeArtifact(ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class PythonCodeArtifact(CodeArtifact):
    requirements: Incomplete
    envVars: Incomplete
    requiredVersion: Incomplete
    def __init__(self, requirements: list[str], envVars: dict[str, str], requiredVersion: str) -> None: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...
    def __eq__(self, o: object) -> bool: ...

class CodeExecutionEnvironment(ABC, metaclass=abc.ABCMeta):
    location: Incomplete
    def __init__(self, loc: InfrastructureLocation) -> None: ...
    def __eq__(self, o: object) -> bool: ...
    @abstractmethod
    def lint(self, eco: Ecosystem, tree: ValidationTree) -> None: ...

class KubernetesEnvironment(CodeExecutionEnvironment):
    hostName: Incomplete
    credential: Incomplete
    def __init__(self, hostName: str, cred: Credential, loc: InfrastructureLocation) -> None: ...
    def lint(self, eco: Ecosystem, tree: ValidationTree): ...

class DataTransformer(ANSI_SQL_NamedObject, Documentable):
    outputDatastore: Incomplete
    trigger: Incomplete
    code: Incomplete
    codeEnv: Incomplete
    documentation: Incomplete
    def __init__(self, name: str, store: Datastore, trigger: TransformerTrigger, code: CodeArtifact, codeEnv: CodeExecutionEnvironment, doc: Optional[Documentation] = None) -> None: ...
    def lint(self, eco: Ecosystem, ws: Workspace, tree: ValidationTree): ...
    def __eq__(self, o: object) -> bool: ...

class Workspace(ANSI_SQL_NamedObject, Documentable):
    dsgs: Incomplete
    dataContainer: Incomplete
    productionStatus: Incomplete
    deprecationStatus: Incomplete
    dataTransformer: Incomplete
    classificationVerifier: Incomplete
    key: Incomplete
    def __init__(self, name: str, *args: Union[DatasetGroup, DataContainer, Documentation, DataClassificationPolicy, ProductionStatus, DeprecationInfo, DataTransformer]) -> None: ...
    def setTeam(self, key: TeamDeclarationKey): ...
    documentation: Incomplete
    def add(self, *args: Union[DatasetGroup, DataContainer, Documentation, DataClassificationPolicy, ProductionStatus, DeprecationInfo, DataTransformer]): ...
    def __hash__(self) -> int: ...
    def __eq__(self, __value: object) -> bool: ...
    def isDatastoreUsed(self, store: Datastore) -> bool: ...
    def lint(self, eco: Ecosystem, gz: GovernanceZone, t: Team, tree: ValidationTree): ...

class PlatformStyle(Enum):
    OLTP: int
    OLAP: int
    COLUMNAR: int
    OBJECT: int
