// Copyright Shareef Jalloq
// SPDX-License-Identifier: MIT
//
// Auto-generated by peakrdl-sv
<%
  from systemrdl.rdltypes import OnReadType, OnWriteType

  lblock = block.inst_name.lower()
  ublock = block.inst_name.upper()

  addr_width = block.addrwidth
  data_width = block.accesswidth
  registers  = block.get_registers()
  num_regs   = len(registers)
  max_regs_char = len("{}".format(num_regs-1))

  # Construct a dict that contains useful
  idx = 0
  reg_enables = {}
  for r in registers:
    key = r.path.lower()
    reg_enables[key] = {}
    reg_enables[key]['idx'] = idx
    reg_enables[key]['we']  = []

    if r.is_wide:
      # If the regwidth > accesswidth, then we need multiple write enables
      for s in range(r.subregs):
        reg_enables[key]['we'].append( f"{r.path.lower()}_{s}_we" )
    else:
      # If regwidth == accesswidth, then we have a single write enable
      reg_enables[key]['we'].append( f"{r.path.lower()}_we" )

    # Increase the index by the subreg count
    idx += r.subregs

  num_regs = idx

%>

module ${lblock}_reg_top
  import rdl_subreg_pkg::*;
#(
  parameter reset_type_e ResetType = ActiveHighSync
) (
  input logic clk,
  input logic rst,

  // Bus I/F
  // REVISIT: hacked to the Migen CSR bus for now.
  input logic csr_we,
  input logic csr_re,
  input logic [6:0] csr_addr,
  input logic [7:0] csr_wdata,
  output logic [7:0] csr_rdata,

  // HW I/F
  output ${lblock}_reg_pkg::${lblock}_reg2hw_t reg2hw, // Write
  input  ${lblock}_reg_pkg::${lblock}_hw2reg_t hw2reg  // Read

);

  import ${lblock}_reg_pkg::*;

  localparam int AW  = ${addr_width};
  localparam int DW  = ${data_width};
  localparam int DBW = DW/8;

  // --------------------------------------------------------------------------------
  // Logic Declarations
  // --------------------------------------------------------------------------------

  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_wstrb;
  logic [DW-1:0]  reg_rdata;


  // --------------------------------------------------------------------------------
  // REVISIT: temporary hack
  // --------------------------------------------------------------------------------

  assign reg_we    = csr_we;
  assign reg_re    = csr_re;
  assign reg_addr  = csr_addr[AW-1:0];
  assign reg_wdata = csr_wdata;
  assign reg_wstrb = '1;
  assign csr_rdata = reg_rdata;


  // --------------------------------------------------------------------------------
  // Software Logic Declarations
  // --------------------------------------------------------------------------------

  % for r in registers:
  % if r.has_sw_writable:
  % for enable in reg_enables[r.path.lower()]['we']:
  logic ${enable};
  % endfor
  % for f in r:
  logic ${sv_bitarray(f)} ${f.path.lower()}_wd;
  % endfor
  % endif
  % endfor

  // --------------------------------------------------------------------------------
  // Field Logic
  // --------------------------------------------------------------------------------

  % for i,r in enumerate(registers):
  % for f in r:
<%

  if len(r) == 1:
    struct_path = f"{r.path}"
  else:
    struct_path = f"{r.path}.{f.inst_name}"

  if f.is_sw_writable:
    if r.is_wide:
      subreg_idx = f.msb // r.accesswidth
      we_expr = reg_enables[r.path.lower()]['we'][subreg_idx]
    else:
      we_expr = f"{r.path.lower()}_we"
    wd_expr = f"{f.path.lower()}_wd"
  else:
    we_expr = ""
    wd_expr = ""

  if f.is_sw_readable:
    qs_expr = f"{f.path}_qs"
  else:
    qs_expr = ""

  if f.is_hw_writable:
    de_expr = f"hw2reg.{struct_path}.de"
    d_expr  = f"hw2reg.{struct_path}.d"
  else:
    de_expr = "'0"
    d_expr = "'0"

  if f.swmod:
    qe_expr = f"reg2hw.{struct_path}.qe"
  else:
    qe_expr = ""

  if f.is_hw_readable:
    q_expr = f"reg2hw.{struct_path}.q"
  else:
    q_expr = ""

%>\
  // Field[${f.name}] ${f.get_bit_slice()}
  % if f.is_sw_readable:
  logic ${sv_bitarray(f)} ${qs_expr};
  % endif
  rdl_subreg #(
    .DW         (${f.width}),
    .ResetType  (ResetType),
    .ResetValue (${reset_gen(f)}),
    .OnRead     (${onread_gen(f)}),
    .OnWrite    (${onwrite_gen(f)})
  ) u_${f.path.lower()} (
    .clk (clk),
    .rst (rst),
    .we  (${we_expr}),
    .wd  (${wd_expr}),
    .de  (${de_expr}),
    .d   (${d_expr}),
    .qs  (${qs_expr}),
    .qe  (${qe_expr}),
    .q   (${q_expr})
  );

  % endfor
  % endfor

  // --------------------------------------------------------------------------------
  // Address Decode
  // --------------------------------------------------------------------------------

  logic [${num_regs-1}:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    % for i,r in enumerate(registers):
<%
    write_enables = reg_enables[r.path.lower()]['we']
    base_idx = reg_enables[r.path.lower()]['idx']
%>\
    % for i,enable in enumerate(write_enables):
<%
    justified = "{}".format(base_idx+i).rjust(max_regs_char)
    param = f"{ublock}_{r.path.upper()}_" + (f"{i}_" if r.is_wide else "") + "OFFSET"
%>\
    addr_hit[${justified}] = (reg_addr == ${param});
    % endfor
    % endfor
  end

  // --------------------------------------------------------------------------------
  // Write Enables
  // --------------------------------------------------------------------------------

  % for i,r in enumerate(registers):
    % if r.has_sw_writable:
${register_we_gen(r,i)}\
    % endif
  % if len(r) == 1:
${field_wd_gen(r[0])}\
  % else:
    % for f in r:
${field_wd_gen(f)}\
    % endfor
  % endif
  % endfor

  // --------------------------------------------------------------------------------
  // Read Data Mux
  // --------------------------------------------------------------------------------

  always_comb begin
    reg_rdata = '0;
    unique case (1'b1)
  % for i, r in enumerate(registers):
<%
    idx = reg_enables[r.path.lower()]['idx']
%>\
    % if r.is_wide:
      % for i in range(r.subregs):
      addr_hit[${idx+i}]: begin
        % for f in r.get_subreg_fields(i):
${rdata_gen(f)}\
        % endfor
      end
      % endfor
    % else:
      addr_hit[${idx}]: begin
      % for f in r:
${rdata_gen(f)}\
      % endfor
      end
    % endif
    ## % for f in r:
##     % if len(r) == 1:
##       addr_hit[${i}]: begin
## ${rdata_gen(r[0])}\
##       end
##     % else:
##       addr_hit[${i}]: begin
##       % for f in r:
##       % endfor
##       end
##     % endif
  % endfor
      default: begin
        reg_rdata = 'X;
      end
    endcase
  end

endmodule
<%def name="register_we_gen(reg, idx)">\
<%
  write_enables = reg_enables[reg.path.lower()]['we']
  idx = reg_enables[reg.path.lower()]['idx']
%>\
  % for i,enable in enumerate(write_enables):
  assign ${enable} = addr_hit[${idx+i}] && reg_we;
  % endfor
</%def>\
<%def name="field_wd_gen(field)">\
  % if field.is_sw_writable:
  assign ${field.path.lower()}_wd = reg_wdata[${field.get_cpuif_bit_slice()}];
  % endif
</%def>\
<%def name="rdata_gen(field, rd_name='reg_rdata')">\
% if field.is_sw_readable:
        ${rd_name}[${field.get_cpuif_bit_slice()}] = ${field.path.lower()}_qs;
% else:
        ${rd_name}[${field.get_cpuif_bit_slice()}] = '0;
% endif
</%def>\
<%def name="onwrite_gen(field)" filter="trim">\
  % if field.onwrite == None:
OnWriteNone
  % elif isinstance(field.onwrite, OnWriteType.woset):
OnWriteWoset
  % elif isinstance(field.onwrite, OnWriteType.woclr):
OnWriteWoclr
  % elif isinstance(field.onwrite, OnWriteType.wot):
OnWriteWot
  % elif isinstance(field.onwrite, OnWriteType.wzs):
OnWriteWzs
  % elif isinstance(field.onwrite, OnWriteType.wzc):
OnWriteWzc
  % elif isinstance(field.onwrite, OnWriteType.wzt):
OnWriteWzt
  % elif isinstance(field.onwrite, OnWriteType.wclr):
OnWriteWclr
  % elif isinstance(field.onwrite, OnWriteType.wset):
OnWriteWset
  % endif
</%def>\
<%def name="onread_gen(field)" filter="trim">\
OnReadNone
</%def>\
<%def name="reset_gen(field)" filter="trim">\
${field.width}'d${field.reset or 0}
</%def>\
<%def name="sv_bitarray(field)" filter="trim">\
% if field.width > 1:
[${field.width-1}:0]
% endif
</%def>\
