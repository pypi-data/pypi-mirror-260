# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_solo.ipynb.

# %% auto 0
__all__ = ['Singleton', 'Empty', 'Module']

# %% ../nbs/05_solo.ipynb 6
#| export


# %% ../nbs/05_solo.ipynb 8
from types import ModuleType
from typing import (Any, )

# %% ../nbs/05_solo.ipynb 10
#| export

# %% ../nbs/05_solo.ipynb 12
#| export

# %% ../nbs/05_solo.ipynb 14
#| export


# %% ../nbs/05_solo.ipynb 16
class Singleton(type):
    __ins__ = {}
    def __new__(cls, name: str = 'Singleton', bases: tuple = (), namespace: dict = {}, **kwargs):
        insdict = namespace.get('__ins__', cls.__ins__)
        insdict.update(cls.__ins__)
        namespace.update(__ins__=insdict)
        if name not in insdict:
            cls.__ins__[name] = super().__new__(cls, name, bases, namespace, **kwargs)
        return cls.__ins__[name]
        
    def __instancecheck__(self, __instance: Any) -> bool: return super().__instancecheck__(__instance)    
    def __subclasscheck__(self, __subclass: type) -> bool: return super().__subclasscheck__(__subclass)
    def __eq__(cls, ins) -> bool:  return isinstance(ins, (cls, cls.__class__))
    def __hash__(cls) -> int: return hash(cls.__name__)
    def __repr__(cls) -> str: return f'<{type(cls).__name__.lower()} {cls.__name__}>'
    def __call__(cls, *args, **kwargs): return cls.__ins__[cls.__name__]

    
class Empty(Singleton): ...
class Module(ModuleType, metaclass=Empty): ...
