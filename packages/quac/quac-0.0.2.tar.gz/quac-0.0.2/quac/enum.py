# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_enum.ipynb.

# %% auto 0
__all__ = ['Species', 'LoaderState']

# %% ../nbs/03_enum.ipynb 6
import io
from enum import StrEnum, auto
from contextlib import redirect_stdout, redirect_stderr
from importlib.machinery import ModuleSpec

# %% ../nbs/03_enum.ipynb 8
from types import ModuleType
from typing import (Union, Optional)

# %% ../nbs/03_enum.ipynb 10
#| export

# %% ../nbs/03_enum.ipynb 12
#| export

# %% ../nbs/03_enum.ipynb 14
#| export

# %% ../nbs/03_enum.ipynb 17
class Species(StrEnum):
    '''Cheeky enum to represent the "species" (i.e. flavor) of a duck-typed protocol.'''
    REG = auto()
    NOT = auto()
    OPT = auto()

# %% ../nbs/03_enum.ipynb 19
class LoaderState(StrEnum):
    '''The state of the module loader.

    Attributes
    ----------
    NONE : auto
        Indicates no state.
    EXECED : auto
        Indicates the module has been executed.
    DUCKED : auto
        Indicates the module has been duck-typed.
    UNKNOWN : auto
        Indicates an unknown state.

    Methods
    -------
    _missing_(value: object) -> 'LoaderState'
        Provides a default for missing values.
    spec(module: ModuleType) -> Optional[ModuleSpec]
        Retrieves the module spec.
    get(module: ModuleType) -> 'LoaderState'
        Retrieves the loader state for a module.
    set(module: ModuleType, state: Optional[Union['LoaderState', str]] = None) -> ModuleType
        Sets the loader state for a module.
    exec(module: ModuleType) -> ModuleType
        Executes the module and sets its state to DUCKED.
    '''
    NONE = auto()
    EXECED = auto()
    DUCKED = auto()
    UNKNOWN = auto()
    
    @classmethod
    def _missing_(cls, value: object) -> 'LoaderState':
        if value is None: return cls.NONE
        return cls.UNKNOWN 
                
    @classmethod
    def spec(cls, module: ModuleType) -> Optional[ModuleSpec]:
        try: return object.__getattribute__(module, '__spec__')
        except: return None
        
    @classmethod
    def get(cls, module: ModuleType) -> 'LoaderState':
        try: return cls(cls.spec(module).loader_state)
        except: return cls.UNKNOWN

    @classmethod
    def set(cls, module: ModuleType, state: Optional[Union['LoaderState', str]] = None) -> ModuleType:
        try: setattr(cls.spec(module), 'loader_state', str(cls(state)))
        except: ...
        return module
        
    @classmethod
    def exec(cls, module: ModuleType) -> ModuleType:
        spec = cls.spec(module)
        with redirect_stdout(io.StringIO()), redirect_stderr(io.StringIO()):
            spec.loader.exec_module(module)
            # try: spec.loader.exec_module(module)
            # except NameError: ...
        return cls.set(module, cls.DUCKED)
